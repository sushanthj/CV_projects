

<!DOCTYPE html>

<html lang="en-US">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">

  

  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

  <link rel="stylesheet" href="/assets/css/just-the-docs-default.css">

  

  
    <script type="text/javascript" src="/assets/js/vendor/lunr.min.js"></script>
  
  <script type="text/javascript" src="/assets/js/just-the-docs.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Constrained RRT | Navigating Robotics</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Constrained RRT" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Projects and assignments during my time in CMU" />
<meta property="og:description" content="Projects and assignments during my time in CMU" />
<link rel="canonical" href="http://localhost:4000/constr_rrt/" />
<meta property="og:url" content="http://localhost:4000/constr_rrt/" />
<meta property="og:site_name" content="Navigating Robotics" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Constrained RRT" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Projects and assignments during my time in CMU","headline":"Constrained RRT","url":"http://localhost:4000/constr_rrt/"}</script>
<!-- End Jekyll SEO tag -->


  

</head>

<body>
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
    <symbol id="svg-link" viewBox="0 0 24 24">
      <title>Link</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link">
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
      </svg>
    </symbol>
    <symbol id="svg-search" viewBox="0 0 24 24">
      <title>Search</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search">
        <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
    </symbol>
    <symbol id="svg-menu" viewBox="0 0 24 24">
      <title>Menu</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
        <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </symbol>
    <symbol id="svg-arrow-right" viewBox="0 0 24 24">
      <title>Expand</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
    </symbol>
    <symbol id="svg-doc" viewBox="0 0 24 24">
      <title>Document</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file">
        <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>
      </svg>
    </symbol>
  </svg>

  <div class="side-bar">
    <div class="site-header">
      <a href="http://localhost:4000/" class="site-title lh-tight">
  Navigating Robotics

</a>
      <a href="#" id="menu-button" class="site-button">
        <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg>
      </a>
    </div>
    <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav">
      
        <ul class="nav-list"><li class="nav-list-item"><a href="http://localhost:4000/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="http://localhost:4000/intro/" class="nav-list-link">Building this Page</a></li><li class="nav-list-item"><a href="http://localhost:4000/planar_homography/" class="nav-list-link">Planar Homography</a></li><li class="nav-list-item"><a href="http://localhost:4000/3D_reconstruction/" class="nav-list-link">3D_reconstruction</a></li><li class="nav-list-item"><a href="http://localhost:4000/optical_flow/" class="nav-list-link">Optical Flow and Image Alignment</a></li><li class="nav-list-item active"><a href="http://localhost:4000/constr_rrt/" class="nav-list-link active">Constrained RRT</a></li><li class="nav-list-item"><a href="http://localhost:4000/spatial_pyramid_matching/" class="nav-list-link">Spatial Pyramid Matching for Scene Classification</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/Deep%20Learning" class="nav-list-link">Deep Learning</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/Basics.html" class="nav-list-link">ML Basics</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/DL.html" class="nav-list-link">Deep Learning Starter</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/IDL1.html" class="nav-list-link">MLPs (IDL1)</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/IDL2.html" class="nav-list-link">Classifiers (IDL2)</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/IDL3.html" class="nav-list-link">Optimizers and Regularizers (IDL3)</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/IDL4.html" class="nav-list-link">Intro to CNNs</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/IDL5.html" class="nav-list-link">Lessons Learnt 1</a></li></ul></li><li class="nav-list-item"><a href="http://localhost:4000/pytorch/" class="nav-list-link">Intro to Pytorch</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/SLAM" class="nav-list-link">SLAM</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Probability_review.html" class="nav-list-link">Recap on Probability</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Expectation_and_cov.html" class="nav-list-link">Expectation and Covariance</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Particle%20Filter_theory.html" class="nav-list-link">Particle Filters Theory</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/EKF.html" class="nav-list-link">EKF</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Non_linear_slam.html" class="nav-list-link">Least Squares SLAM</a></li></ul></li><li class="nav-list-item"><a href="http://localhost:4000/mrsd_proj/" class="nav-list-link">MRSD Capstone Project</a></li><li class="nav-list-item"><a href="http://localhost:4000/camera_model/" class="nav-list-link">Camera Models</a></li><li class="nav-list-item"><a href="http://localhost:4000/numpy/" class="nav-list-link">Numpy</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/Vision%20with%20C++" class="nav-list-link">Computer Vision using C++</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/Vision%20with%20C++/Eigen.html" class="nav-list-link">Linear Algebra in Eigen</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Vision%20with%20C++/Eigen_applied.html" class="nav-list-link">Eigen, OpenCV, and Images</a></li></ul></li></ul>

      
    </nav>
    <footer class="site-footer">
      This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.
    </footer>
  </div>
  <div class="main" id="top">
    <div id="main-header" class="main-header">
      
        <div class="search">
          <div class="search-input-wrap">
            <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Navigating Robotics" aria-label="Search Navigating Robotics" autocomplete="off">
            <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label>
          </div>
          <div id="search-results" class="search-results"></div>
        </div>
      
      
      
        <nav aria-label="Auxiliary" class="aux-nav">
          <ul class="aux-nav-list">
            
              <li class="aux-nav-list-item">
                <a href="//github.com/sushanthj" class="site-button"
                  
                >
                  Sushanth Jayanth's github
                </a>
              </li>
            
          </ul>
        </nav>
      
    </div>
    <div id="main-content-wrap" class="main-content-wrap">
      
        
      
      <div id="main-content" class="main-content" role="main">
        
          <details open="">
  <summary class="text-delta">
    Table of contents
  </summary>
<ol id="markdown-toc">
  <li><a href="#why-constrained-rrt" id="markdown-toc-why-constrained-rrt">Why Constrained RRT?</a></li>
  <li><a href="#generic-rrt" id="markdown-toc-generic-rrt">Generic RRT</a>    <ol>
      <li><a href="#sampling-in-generic-rrt" id="markdown-toc-sampling-in-generic-rrt">Sampling in Generic RRT</a></li>
    </ol>
  </li>
  <li><a href="#constrained-rrt" id="markdown-toc-constrained-rrt">Constrained RRT</a>    <ol>
      <li><a href="#constraining-sampled-points" id="markdown-toc-constraining-sampled-points">Constraining Sampled Points</a></li>
      <li><a href="#defining-constraints-in-code" id="markdown-toc-defining-constraints-in-code">Defining constraints in code</a>        <ol>
          <li><a href="#projection-function" id="markdown-toc-projection-function">Projection Function</a></li>
          <li><a href="#introducing-constraints-to-rrt" id="markdown-toc-introducing-constraints-to-rrt">Introducing constraints to RRT</a></li>
          <li><a href="#implementation" id="markdown-toc-implementation">Implementation</a></li>
        </ol>
      </li>
      <li><a href="#testing-in-simulation" id="markdown-toc-testing-in-simulation">Testing in Simulation</a></li>
    </ol>
  </li>
  <li><a href="#testing-in-real-life" id="markdown-toc-testing-in-real-life">Testing in Real Life</a></li>
  <li><a href="#acknowledgement" id="markdown-toc-acknowledgement">Acknowledgement</a></li>
</ol>

</details>

<iframe width="560" height="315" src="https://www.youtube.com/embed/crSy8L9eDcg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
      <h1 id="why-constrained-rrt">
        
        
          <a href="#why-constrained-rrt" class="anchor-heading" aria-labelledby="why-constrained-rrt"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Why Constrained RRT?
        
        
      </h1>
    

<p>As part of my autonomy project, we needed to pickup a tray and place it in a shelf.</p>

<p>Generic RRT helps plan trajectories from say the table -&gt; shelf. However, RRT gives only joint
angles which are within the robot’s config space and has no obstacle collisions. In our use-case
we needed a plan (trajectory) which ensures that the tray stays level throughout the journey
from the table -&gt; shelf.</p>

<p>Formally, the constraints mentioned above are:</p>

<ul>
  <li>Roll = 0</li>
  <li>Pitch = 0</li>
  <li>Yaw = no constraint</li>
</ul>
      <h1 id="generic-rrt">
        
        
          <a href="#generic-rrt" class="anchor-heading" aria-labelledby="generic-rrt"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Generic RRT
        
        
      </h1>
    

<p><img src="/images/constrained_rrt/rrt_high_level.png" alt="" /></p>

<p><img src="/images/constrained_rrt/connect.png" alt="" /></p>
      <h2 id="sampling-in-generic-rrt">
        
        
          <a href="#sampling-in-generic-rrt" class="anchor-heading" aria-labelledby="sampling-in-generic-rrt"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Sampling in Generic RRT
        
        
      </h2>
    

<p>Vanilla RRT uses simple joint constraints, within which it queries for random samples. The
image below shows the Franka Panda robot which will be used in this project. The Franka has
<strong>8 joints</strong> which also includes the end effector.</p>

<p><img src="/images/constrained_rrt/franks.png" alt="" /></p>

<p>In vanilla RRT, the joints are given some basic constraints (based on design of the robot)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">self</span><span class="p">.</span><span class="n">qmin</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">2.8973</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.7628</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.8973</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0718</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.8973</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0175</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.8973</span><span class="p">]</span> <span class="c1"># NOTE-does not include grippers
</span><span class="bp">self</span><span class="p">.</span><span class="n">qmax</span><span class="o">=</span><span class="p">[</span><span class="mf">2.8973</span><span class="p">,</span> <span class="mf">1.7628</span><span class="p">,</span> <span class="mf">2.8973</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0698</span><span class="p">,</span> <span class="mf">2.8973</span><span class="p">,</span> <span class="mf">3.7525</span><span class="p">,</span> <span class="mf">2.8973</span><span class="p">]</span> <span class="c1"># NOTE-does not include gripper
</span></code></pre></div></div>

<p>RRT Then works by simply sampling randomly in the limits of qmin and qmax</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">SampleRobotConfig</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">q</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
			<span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">qmin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">qmax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="p">.</span><span class="n">qmin</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">q</span>
</code></pre></div></div>

<p><strong>Let’s call new sampled joints as vertices (like nodes in a graph) and any two edges are
by edges (like edges in a graph)</strong></p>

<p>Checks on sampled points:</p>

<ul>
  <li>We then check for collisions along these sampled joint angles.</li>
  <li><em>Note. In other methodws like PRM (probabalistic roadmaps), the configuration space is
queried beforehand and is stored to reduce search time</em></li>
  <li>However, if we sample vertices that are too far away, we will have to constrain the expansion
<img src="/images/constrained_rrt/extension.png" alt="" /></li>
  <li>We also need to check if one of our vertices is close enough to the goal to say we’ve reached</li>
  <li>Note. We also introduce a goal bias by directly setting the sample config = goal config say
2% of the time.</li>
</ul>

<p>These checks are shown below:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">RRTQuery</span><span class="p">():</span>

	<span class="k">global</span> <span class="n">FoundSolution</span>
	<span class="k">global</span> <span class="n">plan</span>
	<span class="k">global</span> <span class="n">rrtVertices</span>
	<span class="k">global</span> <span class="n">rrtEdges</span>

	<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">rrtVertices</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">3000</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">FoundSolution</span><span class="p">:</span>

		<span class="c1"># TODO : Fill in the algorithm here
</span>		<span class="c1"># create a random node (x,y as a 2,1 array)
</span>		<span class="n">qRand</span> <span class="o">=</span> <span class="n">mybot</span><span class="p">.</span><span class="n">SampleRobotConfig</span><span class="p">()</span>

		<span class="c1"># introduce the goal bias. (set the random node as goal with a certain prob)
</span>		<span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">:</span>
			<span class="n">qRand</span> <span class="o">=</span> <span class="n">qGoal</span>

		<span class="n">idNear</span> <span class="o">=</span> <span class="n">FindNearest</span><span class="p">(</span><span class="n">rrtVertices</span><span class="p">,</span> <span class="n">qRand</span><span class="p">)</span>
		<span class="n">qNear</span> <span class="o">=</span> <span class="n">rrtVertices</span><span class="p">[</span><span class="n">idNear</span><span class="p">]</span>

		<span class="n">qNear</span><span class="p">,</span> <span class="n">qRand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qNear</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qRand</span><span class="p">)</span>

		<span class="c1"># if it's above threshold, move in the direction of the new node, but only upto the
</span>		<span class="c1"># threshold (which limits max distance between two nodes)
</span>		<span class="k">while</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">qRand</span> <span class="o">-</span> <span class="n">qNear</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">:</span>
			<span class="c1"># qConnect = qNear + thres * unit_vector_pointing_towards_qRand
</span>			<span class="n">qConnect</span> <span class="o">=</span> <span class="n">qNear</span> <span class="o">+</span> <span class="n">thresh</span> <span class="o">*</span> <span class="p">((</span><span class="n">qRand</span><span class="o">-</span><span class="n">qNear</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">qRand</span><span class="o">-</span><span class="n">qNear</span><span class="p">))</span>

			<span class="k">if</span> <span class="ow">not</span> <span class="n">mybot</span><span class="p">.</span><span class="n">DetectCollisionEdge</span><span class="p">(</span><span class="n">qConnect</span><span class="p">,</span> <span class="n">qNear</span><span class="p">,</span> <span class="n">pointsObs</span><span class="p">,</span> <span class="n">axesObs</span><span class="p">):</span>
				<span class="n">rrtVertices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">qConnect</span><span class="p">)</span>
				<span class="n">rrtEdges</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">idNear</span><span class="p">)</span>
				<span class="n">qNear</span> <span class="o">=</span> <span class="n">qConnect</span>

			<span class="k">else</span><span class="p">:</span>
				<span class="k">break</span>

		<span class="c1"># check for collisions
</span>		<span class="n">qConnect</span> <span class="o">=</span> <span class="n">qRand</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">mybot</span><span class="p">.</span><span class="n">DetectCollisionEdge</span><span class="p">(</span><span class="n">qConnect</span><span class="p">,</span> <span class="n">qNear</span><span class="p">,</span> <span class="n">pointsObs</span><span class="p">,</span> <span class="n">axesObs</span><span class="p">):</span>
			<span class="c1"># if no collision in new joint angles (qConnect), then add as a valid node and edge
</span>			<span class="n">rrtVertices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">qConnect</span><span class="p">)</span>
			<span class="n">rrtEdges</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">idNear</span><span class="p">)</span>

		<span class="c1"># check if the qGoal is close to some node
</span>		<span class="n">idNear</span> <span class="o">=</span> <span class="n">FindNearest</span><span class="p">(</span><span class="n">rrtVertices</span><span class="p">,</span> <span class="n">qGoal</span><span class="p">)</span>
		<span class="c1"># if the qGoal is really close (&lt; 0.025) then we've pretty much reached goal!
</span>		<span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qGoal</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rrtVertices</span><span class="p">[</span><span class="n">idNear</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mf">0.025</span><span class="p">:</span>
			<span class="c1"># add the goal node as our final node
</span>			<span class="n">rrtVertices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">qGoal</span><span class="p">)</span>
			<span class="n">rrtEdges</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">idNear</span><span class="p">)</span>
			<span class="k">print</span><span class="p">(</span><span class="s">"SOLUTION FOUND"</span><span class="p">)</span>
			<span class="n">FoundSolution</span> <span class="o">=</span> <span class="bp">True</span>

		<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rrtVertices</span><span class="p">))</span>
</code></pre></div></div>
      <h1 id="constrained-rrt">
        
        
          <a href="#constrained-rrt" class="anchor-heading" aria-labelledby="constrained-rrt"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Constrained RRT
        
        
      </h1>
    

<p>We saw above some tricks to make simple RRT work. Now, with one small modification we
can also make it work in a constrained manner.</p>
      <h2 id="constraining-sampled-points">
        
        
          <a href="#constraining-sampled-points" class="anchor-heading" aria-labelledby="constraining-sampled-points"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Constraining Sampled Points
        
        
      </h2>
    

<ul>
  <li>To constrain the sampled points, we simply project the config space of the sampled points
to the constrained config space</li>
  <li>This projection was described by <a href="https://www.ri.cmu.edu/pub_files/2009/5/berenson_dmitry_2009_2.pdf">Berenson, Siddhartha S. etal</a></li>
  <li>The process of projecting sample_points -&gt; valid_config_space is achieved by gradient descent
<img src="/images/constrained_rrt/Robot%20Autonomy%20Final%20Project.png" alt="" /></li>
</ul>

<p>In a simple manner, we essentially do the following:</p>
<ul>
  <li>Define a state vector for the end effector</li>
  <li>Define a cost function which uses certain elements in the above state vector</li>
  <li>Minimize this cost function to obtain the valid config-space needed</li>
</ul>

<p><img src="/images/constrained_rrt/math.png" alt="" /></p>

<p>In the above picture, the cost function seeks to minimize the roll and pitch of the end effector</p>

<p>The final equation shows the update step (gradient descent)</p>
      <h2 id="defining-constraints-in-code">
        
        
          <a href="#defining-constraints-in-code" class="anchor-heading" aria-labelledby="defining-constraints-in-code"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Defining constraints in code
        
        
      </h2>
    
      <h3 id="projection-function">
        
        
          <a href="#projection-function" class="anchor-heading" aria-labelledby="projection-function"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Projection Function
        
        
      </h3>
    

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">project_to_constrain</span><span class="p">(</span><span class="n">qRand</span><span class="p">):</span>
	<span class="s">"""
	Project to make roll and pitch zero where possible. We do this by gradient descent

	Our cost function is C = (3.14 - roll)**2 + pitch**2 (we want to minize roll and pitch)
	NOTE: (3.14 - roll) since we have init roll of 3.14
	"""</span>

	<span class="c1"># do forward kinematics and get the roll, pitch at qRand
</span>	<span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="n">get_roll_pitch_of_rand_pt</span><span class="p">(</span><span class="n">qRand</span><span class="p">)</span>
	<span class="c1"># print(f"init roll={roll} and pitch={pitch} and yaw={yaw}")
</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">starting_roll</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">roll</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="n">rejection_threshold</span> <span class="ow">or</span> \
		<span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">starting_pitch</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pitch</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">rejection_threshold</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">qRand</span><span class="p">,</span> <span class="bp">True</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

	<span class="c1"># while(((starting_roll-abs(roll))**2 + pitch**2 + (starting_yaw - abs(yaw)) &gt; cost_thresh) and count &lt; 1000):
</span>	<span class="k">while</span><span class="p">(((</span><span class="n">starting_roll</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">roll</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">starting_pitch</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">pitch</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="n">cost_thresh</span><span class="p">)</span>
       		<span class="ow">and</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">):</span>
		<span class="n">grad_cost_wrt_xyzrpy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">roll</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pitch</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">gradient</span> <span class="o">=</span> <span class="n">J</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">grad_cost_wrt_xyzrpy</span>

		<span class="n">qRand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">qRand</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">gradient</span>
		<span class="n">qRand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">qRand</span><span class="p">).</span><span class="n">tolist</span><span class="p">()</span>
		<span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="n">get_roll_pitch_of_rand_pt</span><span class="p">(</span><span class="n">qRand</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

	<span class="c1"># print(f"final roll={roll} and pitch={pitch} and yaw={yaw}")
</span>
	<span class="k">return</span> <span class="n">qRand</span><span class="p">,</span> <span class="bp">False</span>


<span class="k">def</span> <span class="nf">get_roll_pitch_of_rand_pt</span><span class="p">(</span><span class="n">qRand</span><span class="p">):</span>
	<span class="c1"># do forward kinematics and get the Tcurr, J at qRand
</span>	<span class="n">Tcurr</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="n">mybot</span><span class="p">.</span><span class="n">ForwardKin_for_check</span><span class="p">(</span><span class="n">qRand</span><span class="p">)</span>
	<span class="n">last_link_rotation</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Tcurr</span><span class="p">[</span><span class="n">joint_to_constrain</span><span class="p">])[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">Rotation</span><span class="p">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">last_link_rotation</span><span class="p">)</span>
	<span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">as_euler</span><span class="p">(</span><span class="s">'xyz'</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span><span class="p">,</span> <span class="n">J</span>
</code></pre></div></div>
      <h3 id="introducing-constraints-to-rrt">
        
        
          <a href="#introducing-constraints-to-rrt" class="anchor-heading" aria-labelledby="introducing-constraints-to-rrt"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Introducing constraints to RRT
        
        
      </h3>
    

<p>In addition to the steps specified in the algorithm above, I needed to tune some hyperparameters
to make it work. Specifically <strong>Rejection Threshold</strong>, <strong>Learning Rate</strong>, <strong>Cost Threshold</strong>.</p>

<ol>
  <li>Even before doing gradient descent, I verify if the end effector state (specifically roll
 and pitch) are within 1 radian from my goal state (zero roll and zero pitch). This sped up
 the algorithm, possibly because it takes longer to compute the jacobian and do gradient
 descent for samples that are too far away from desired state.</li>
  <li>Secondly, I needed to tune the learning rate of the gradient descent step</li>
  <li>I also had to define a threshold within which the cost function would need to optimize wihtin
 (it would take forever if I wanted roll^2 + pitch^2 == 0), therefore I let gradient descent
 to run uptill roll^2 + pitch^2 &lt; 0.2</li>
</ol>
      <h3 id="implementation">
        
        
          <a href="#implementation" class="anchor-heading" aria-labelledby="implementation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Implementation
        
        
      </h3>
    

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">RRTQuery</span><span class="p">():</span>

	<span class="k">global</span> <span class="n">FoundSolution</span>
	<span class="k">global</span> <span class="n">plan</span>
	<span class="k">global</span> <span class="n">rrtVertices</span>
	<span class="k">global</span> <span class="n">rrtEdges</span>

	<span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="n">get_roll_pitch_of_rand_pt</span><span class="p">(</span><span class="n">qInit</span><span class="p">)</span>
	<span class="k">print</span><span class="p">(</span><span class="s">"starting roll, pitch, and yaw"</span><span class="p">,</span> <span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span><span class="p">)</span>

	<span class="c1"># making the assumption that we should find solution within 3000 iterations
</span>	<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">rrtVertices</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">10000</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">FoundSolution</span><span class="p">:</span>

		<span class="c1"># TODO : Fill in the algorithm here
</span>		<span class="c1"># create a random node (x,y as a 2,1 array)
</span>		<span class="n">qRand</span> <span class="o">=</span> <span class="n">mybot</span><span class="p">.</span><span class="n">SampleRobotConfig</span><span class="p">()</span>

		<span class="c1"># introduce the goal bias. (set the random node as goal with a certain prob)
</span>		<span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">:</span>
			<span class="n">qRand</span> <span class="o">=</span> <span class="n">qGoal</span>

		<span class="s">"""Constrained RRT step"""</span>
		<span class="c1"># NOTE: now that we have a qRand, if we want this qRand to be such that the
</span>		<span class="c1"># end effector has roll and pitch as zero
</span>		<span class="n">qRand</span><span class="p">,</span> <span class="n">flag_1</span> <span class="o">=</span> <span class="n">project_to_constrain</span><span class="p">(</span><span class="n">qRand</span><span class="p">)</span>
		<span class="n">flag_2</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qRand</span><span class="p">)):</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qRand</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mybot</span><span class="p">.</span><span class="n">qmax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">qRand</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mybot</span><span class="p">.</span><span class="n">qmin</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
				<span class="n">flag_2</span> <span class="o">=</span> <span class="bp">True</span>

		<span class="c1"># flag_1 -&gt; being true denotes that we couldn't project
</span>		<span class="c1"># flag_2 -&gt; being true denotes that we got infeasible joint angles
</span>		<span class="c1"># print(flag_1, flag_2)
</span>		<span class="k">if</span> <span class="n">flag_1</span> <span class="ow">or</span> <span class="n">flag_2</span><span class="p">:</span>
			<span class="k">continue</span>
		<span class="s">"""End of Constrained RRT"""</span>

		<span class="n">idNear</span> <span class="o">=</span> <span class="n">FindNearest</span><span class="p">(</span><span class="n">rrtVertices</span><span class="p">,</span> <span class="n">qRand</span><span class="p">)</span>
		<span class="n">qNear</span> <span class="o">=</span> <span class="n">rrtVertices</span><span class="p">[</span><span class="n">idNear</span><span class="p">]</span>

		<span class="n">qNear</span><span class="p">,</span> <span class="n">qRand</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qNear</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qRand</span><span class="p">)</span>

		<span class="c1"># if it's above threshold, move in the direction of the new node, but only upto the
</span>		<span class="c1"># threshold (which limits max distance between two nodes)
</span>		<span class="k">while</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">qRand</span> <span class="o">-</span> <span class="n">qNear</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">:</span>
			<span class="c1"># qConnect = qNear + thres * unit_vector_pointing_towards_qRand
</span>			<span class="n">qConnect</span> <span class="o">=</span> <span class="n">qNear</span> <span class="o">+</span> <span class="n">thresh</span> <span class="o">*</span> <span class="p">((</span><span class="n">qRand</span><span class="o">-</span><span class="n">qNear</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">qRand</span><span class="o">-</span><span class="n">qNear</span><span class="p">))</span>

			<span class="s">"""Constrained RRT step"""</span>
			<span class="c1"># NOTE: now that we have a qRand, if we want this qRand to be such that the
</span>			<span class="c1"># end effector has roll and pitch as zero
</span>			<span class="n">qConnect</span><span class="p">,</span> <span class="n">flag_1</span> <span class="o">=</span> <span class="n">project_to_constrain</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">.</span><span class="n">tolist</span><span class="p">(</span><span class="n">qConnect</span><span class="p">))</span>
			<span class="n">flag_2</span> <span class="o">=</span> <span class="bp">False</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qRand</span><span class="p">)):</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">qConnect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mybot</span><span class="p">.</span><span class="n">qmax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">qRand</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mybot</span><span class="p">.</span><span class="n">qmin</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
					<span class="n">flag_2</span> <span class="o">=</span> <span class="bp">True</span>

			<span class="c1"># flag_1 -&gt; being true denotes that we couldn't project
</span>			<span class="c1"># flag_2 -&gt; being true denotes that we got infeasible joint angles
</span>			<span class="c1"># print(flag_1, flag_2)
</span>			<span class="k">if</span> <span class="n">flag_1</span> <span class="ow">or</span> <span class="n">flag_2</span><span class="p">:</span>
				<span class="k">break</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">qConnect</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qConnect</span><span class="p">)</span>
			<span class="s">"""End of Constrained RRT"""</span>

			<span class="k">if</span> <span class="ow">not</span> <span class="n">mybot</span><span class="p">.</span><span class="n">DetectCollisionEdge</span><span class="p">(</span><span class="n">qConnect</span><span class="p">,</span> <span class="n">qNear</span><span class="p">,</span> <span class="n">pointsObs</span><span class="p">,</span> <span class="n">axesObs</span><span class="p">):</span>
				<span class="n">rrtVertices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">qConnect</span><span class="p">)</span>
				<span class="n">rrtEdges</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">idNear</span><span class="p">)</span>
				<span class="n">qNear</span> <span class="o">=</span> <span class="n">qConnect</span>

			<span class="k">else</span><span class="p">:</span>
				<span class="k">break</span>

		<span class="c1"># check for collisions
</span>		<span class="n">qConnect</span> <span class="o">=</span> <span class="n">qRand</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">mybot</span><span class="p">.</span><span class="n">DetectCollisionEdge</span><span class="p">(</span><span class="n">qConnect</span><span class="p">,</span> <span class="n">qNear</span><span class="p">,</span> <span class="n">pointsObs</span><span class="p">,</span> <span class="n">axesObs</span><span class="p">):</span>
			<span class="c1"># if no collision in new joint angles (qConnect), then add as a valid node and edge
</span>			<span class="n">rrtVertices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">qConnect</span><span class="p">)</span>
			<span class="n">rrtEdges</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">idNear</span><span class="p">)</span>

		<span class="c1"># check if the qGoal is close to some node
</span>		<span class="n">idNear</span> <span class="o">=</span> <span class="n">FindNearest</span><span class="p">(</span><span class="n">rrtVertices</span><span class="p">,</span> <span class="n">qGoal</span><span class="p">)</span>
		<span class="c1"># if the qGoal is really close (&lt; 0.025) then we've pretty much reached goal!
</span>		<span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qGoal</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rrtVertices</span><span class="p">[</span><span class="n">idNear</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mf">0.025</span><span class="p">:</span>
			<span class="c1"># add the goal node as our final node
</span>			<span class="n">rrtVertices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">qGoal</span><span class="p">)</span>
			<span class="n">rrtEdges</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">idNear</span><span class="p">)</span>
			<span class="k">print</span><span class="p">(</span><span class="s">"SOLUTION FOUND"</span><span class="p">)</span>
			<span class="n">FoundSolution</span> <span class="o">=</span> <span class="bp">True</span>

		<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rrtVertices</span><span class="p">))</span>
</code></pre></div></div>
      <h2 id="testing-in-simulation">
        
        
          <a href="#testing-in-simulation" class="anchor-heading" aria-labelledby="testing-in-simulation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Testing in Simulation
        
        
      </h2>
    

<p>The above code was tested using Mujoco simulator. I’ve shown comparisons between
vanilla and constrained RRT</p>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th style="text-align: left">Vanilla RRT</th>
      <th style="text-align: left">Constrained RRT</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><img src="/images/constrained_rrt/rrt_plain_AdobeExpress.gif" alt="" /></td>
      <td style="text-align: left"><img src="/images/constrained_rrt/rrt_mod_AdobeExpress.gif" alt="" /></td>
    </tr>
  </tbody>
</table></div>
      <h1 id="testing-in-real-life">
        
        
          <a href="#testing-in-real-life" class="anchor-heading" aria-labelledby="testing-in-real-life"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Testing in Real Life
        
        
      </h1>
    

<iframe width="560" height="315" src="https://www.youtube.com/embed/crSy8L9eDcg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
      <h1 id="acknowledgement">
        
        
          <a href="#acknowledgement" class="anchor-heading" aria-labelledby="acknowledgement"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Acknowledgement
        
        
      </h1>
    

<p>I’d like to thank my team-mate <a href="https://www.linkedin.com/in/guangzhao-zack-li-31025468">Zack</a>
for working beside me throughout this project</p>

        

        

        
        
          <hr>
          <footer>
            

            <p class="text-small text-grey-dk-100 mb-0"></p>

            
              <div class="d-flex mt-2">
                
                
              </div>
            
          </footer>
        

      </div>
    </div>

    
      

      <div class="search-overlay"></div>
    
  </div>
</body>
</html>

