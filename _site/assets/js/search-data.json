{"0": {
    "doc": "Git Concepts",
    "title": "Before you Begin",
    "content": "Reference . In the above link, follow the procedures, but instead of using username and password each time, setup the ssh keys and use them more often . ssh keys are found in ./.ssh folder (or lookup keygen to generate your keys) . ",
    "url": "http://localhost:4000/git_concepts#before-you-begin",
    "relUrl": "/git_concepts#before-you-begin"
  },"1": {
    "doc": "Git Concepts",
    "title": "Basics of generating new content in local and pushing to github",
    "content": " ",
    "url": "http://localhost:4000/git_concepts#basics-of-generating-new-content-in-local-and-pushing-to-github",
    "relUrl": "/git_concepts#basics-of-generating-new-content-in-local-and-pushing-to-github"
  },"2": {
    "doc": "Git Concepts",
    "title": "Process for adding to a github page",
    "content": "git add . git commit -m “made new code” git push or git push origin develop (if you cloned from develop branch) . ",
    "url": "http://localhost:4000/git_concepts#process-for-adding-to-a-github-page",
    "relUrl": "/git_concepts#process-for-adding-to-a-github-page"
  },"3": {
    "doc": "Git Concepts",
    "title": "If you want to track a different branch",
    "content": ". | git branch –set-upstream-to=origin/master git add . git push | . or make a new remote . | git remote add ts_origin_wiki git@github.com:sjayanth21/BR_Wiki.git git push –set-upstream ts_origin_wiki master git push ts_origin_wiki_master | . ",
    "url": "http://localhost:4000/git_concepts#if-you-want-to-track-a-different-branch",
    "relUrl": "/git_concepts#if-you-want-to-track-a-different-branch"
  },"4": {
    "doc": "Git Concepts",
    "title": "Working with remotes",
    "content": "Any folder can have a number of remotes like: origin and ts_origin_github . To make local branch master track a different remote branch (branch in your cloud github repo) do: git branch –set-upstream-to=origin/master . or git branch –set-upstream-to=origin/develop . ",
    "url": "http://localhost:4000/git_concepts#working-with-remotes",
    "relUrl": "/git_concepts#working-with-remotes"
  },"5": {
    "doc": "Git Concepts",
    "title": "If you cloned a repo, forked your own branch (using git checkout)",
    "content": "You may need to pull from upstream to update your codebase However, running a simple ‘git pull’ may throw merge conflicts . So do the following . | Run a ‘git fetch’ to get the updates on all branches (and if any new branch has been added) | In your personal branch commit all changes by doing: git add, commit and push | sudo apt install meld | Now to get the upstream updates do ‘git checkout develop’ (whichever is the main branch) | Now to put this in your personal branch run ‘git checkout feature/sj’ | Now we do the actual merging using ‘git merge develop’ (this will merge everythin in deveop into the current branch viz feature/sj) | The above step would have thrown some merge conflicts, to solve that run ‘git mergetool’ | The above step opens meld, make all necessary resolutions and save | Now our codebase would have been updated to whatever we resolved in meld | Now run ‘git commit’ without any arguments as it is a ‘merge commit’ | Now as usual do ‘git push origin feature/sj’ to push your updated personal branch to github | . ",
    "url": "http://localhost:4000/git_concepts#if-you-cloned-a-repo-forked-your-own-branch-using-git-checkout",
    "relUrl": "/git_concepts#if-you-cloned-a-repo-forked-your-own-branch-using-git-checkout"
  },"6": {
    "doc": "Git Concepts",
    "title": "Points to Note",
    "content": ". | If you checkout a file ‘git checkout blade.py’ it resets the file to whatever is the latest from that branch in upstream . | If you want to physically add or change remotes go to the respective folder and do ‘nano .git/config’ . | the correct syntax for the merge command is: ‘git merge ts_origin/master’ What this does is that if the current branch is origin/develop it will merge the files of current branch i.e origin/develop with ts_origin/master . | Note that even if ts_origin/master is in ts_github account and origin/master is in sushanthj github account, it will still merge as long as remotes exist for both these accounts. If remotes don’t exist, you can always add as shown up above . | . Concepts for working with two repos or two repos on two different github accounts: . Basically locally you will have ‘master’ branch if you do ‘git branch’ This master can track two upstream branches using two different remotes One remote is added automatically when you clone the repo The next remote will have to be added manually to your other git account or other repo . Then to push the same commit to both branches first do ‘git push’ and see which repo it pushes to (say it pushes to origin/master Then do ‘git push –set-upstream ts_origin/develop’ to push to your second repo However, do note that your local branch always tracks to the latest branch you pushed to i.e if you do a git pull, it will pull from the latest branch to which you pushed in this case it will pull from ts_origin/develop . Saving a patch file . If you have changes made which you want to save locally and not push to remote, you can save a patch file . git diff &gt; new_changes.patch . Now to apply this patch onto any branch, do: . git apply new_changes.patch . Saving changes by stashing . Instead of saving a specific file for changes (such as a patch file), you could also stash your changes locally . git stash . The above command will stash all tracked changes. You could also stash only committed changes. Refer: stashing . To then apply the stashed changes (one time use only as pop will remove from stash) . git stash pop . To apply without popping do: . git stash apply . To remove any particular item in stash: . git stash drop . To view all entries in stash and then apply specific one do: . git stash list git stash apply n . n = stash item number . ",
    "url": "http://localhost:4000/git_concepts#points-to-note",
    "relUrl": "/git_concepts#points-to-note"
  },"7": {
    "doc": "Git Concepts",
    "title": "Git Concepts",
    "content": ". | Before you Begin | Basics of generating new content in local and pushing to github . | Process for adding to a github page | If you want to track a different branch | Working with remotes | If you cloned a repo, forked your own branch (using git checkout) | Points to Note . | Concepts for working with two repos or two repos on two different github accounts: | Saving a patch file | Saving changes by stashing | . | . | . ",
    "url": "http://localhost:4000/git_concepts",
    "relUrl": "/git_concepts"
  },"8": {
    "doc": "Intro",
    "title": "To better your experience of writing in code",
    "content": "Download the following extensions in vscode: . | Markdown All in one | code runner (see youtube video on how to setup vscode for C++) | . ",
    "url": "http://localhost:4000/intro/#to-better-your-experience-of-writing-in-code",
    "relUrl": "/intro/#to-better-your-experience-of-writing-in-code"
  },"9": {
    "doc": "Intro",
    "title": "Shortcuts in general pour toi",
    "content": ". | Once Markdown all in one is installed, you can do ctrl+shift+v to see preview of markdown immediately | To run any C++ file it’s just ctrl+shift+n | If you want to bold any specific text in markdown just select the text by holding down ctrl+shift and using arrow keys to select the required text. Then once text is selected just do ctrl+b to bolden and ctrl+i to italicize . | click on tab after using - for normal bullet pointing to get sub-points | . | To get numbered list continuously, in-between two headings 1. and 2. all content should be indented with 4 spaces in the markdown script . | To shift between windows in ubuntu, just do windows_key+shift+right/left_arrow | To minimize or unmaximize any window in hold down alt and press space, then choose to minimize | To then maximize or move window to right half/left half of screen, windows_key+shift+right/left_arrow | . ",
    "url": "http://localhost:4000/intro/#shortcuts-in-general-pour-toi",
    "relUrl": "/intro/#shortcuts-in-general-pour-toi"
  },"10": {
    "doc": "Intro",
    "title": "Intro",
    "content": "For Jekyll reference see just_the_docs . The following pages are built in order to understand Computer Vision and Machine Learning . To deploy on heroku follow the steps in the link below (and use the gem files, rake files and proc files in this repo for reference) . The following files will need to be copied from this repo: . | config.ru | Rakefile | Procfile | static.json | config.yaml (modify this file as per requirement) | Gemfile | . And only if necessary: . | Gemfile.lock | remove _sites from .gitignore | . Run bundle once to intialize Run bundle exec jekyll serve Go to the specified webpage by the above command . After copying these files (or their necessary contents), install heroku cli and do: . heroku login . Then do heroku create as per the below link and the other steps necessary (git push heroku master) . Deploy jekyll on heroku . Finally, go to heroku page -&gt; settings -&gt; change the name of the app and find the url . ",
    "url": "http://localhost:4000/intro/",
    "relUrl": "/intro/"
  },"11": {
    "doc": "Numpy",
    "title": "Before you Begin",
    "content": "Official Documentation . Numpy and Scipy are two resources to compute a variety of functions on matrices. Scipy is built on top of numpy and has a larger codebase of modules which we can utilize . ",
    "url": "http://localhost:4000/numpy/#before-you-begin",
    "relUrl": "/numpy/#before-you-begin"
  },"12": {
    "doc": "Numpy",
    "title": "Images and Arrays",
    "content": " ",
    "url": "http://localhost:4000/numpy/#images-and-arrays",
    "relUrl": "/numpy/#images-and-arrays"
  },"13": {
    "doc": "Numpy",
    "title": "Image Operations",
    "content": "Importing Images . In the below code we input an image and convert it into an array. Shape of an array is just it’s size . im = array(Image.open('empire.jpg')) print im.shape, im.dtype . The output would look lik this: . (800, 569, 3) uint8 (RGB image) . Converting image to Greyscale . This uses an extra library called Python Pillow . from PIL import Image, ImageOps im = array(Image.open('empire.jpg').convert('L'),'f') print im.shape, im.dtype . Plotting an image . img = np.array(Image.open('House2.jpg')) plt.figure(figsize=(8,8)) plt.imshow(img) plt.show . ",
    "url": "http://localhost:4000/numpy/#image-operations",
    "relUrl": "/numpy/#image-operations"
  },"14": {
    "doc": "Numpy",
    "title": "Array Functions and Operations",
    "content": " ",
    "url": "http://localhost:4000/numpy/#array-functions-and-operations",
    "relUrl": "/numpy/#array-functions-and-operations"
  },"15": {
    "doc": "Numpy",
    "title": "Array Nomenclature",
    "content": ". It’s important to realise that we only care about shapes of a matrix and our computation revolves around the shape tuple (1,2,3) irrespective of which is row or column. Develop a generalized version of matrix definitions!! . An image can have shape as (640,540,3). Here we need to think in the way that there are 640 rows and 540 columns and 3 RGB channels. Therefore, rows, columns, pages don’t matter much. Just think in terms of shapes. sum() function in 1D . import numpy as np arr = [20, 2, .2, 10, 4] print(\"\\nSum of arr : \", np.sum(arr)) print(\"Sum of arr(uint8) : \", np.sum(arr, dtype = np.uint8)) print(\"Sum of arr(float32) : \", np.sum(arr, dtype = np.float32)) . Output: . Sum of arr : 36.2 Sum of arr(uint8) : 36 Sum of arr(float32) : 36.2 . In 1D it just computes the sum of all elements in the array. It can also do type conversion on the go. We can extend this same logic to 2D, there too it calculates the sum of all matrix elements . sum() in 2D along axes . Axis along which we want to calculate the sum value. Otherwise, it will consider arr to be flattened(works on all the axis). axis = 0 means it calculates sum of all elements in ith column and (i=1)th column.. axis = 1 means it calculates sum of all elements in (j)th column and (j+1)th column.. arr = [[14, 17, 12, 33, 44], [15, 6, 27, 8, 19], [23, 2, 54, 1, 4,]] print(\"\\nSum of arr : \", np.sum(arr)) print(\"Sum of arr(axis = 0) : \", np.sum(arr, axis = 0)) print(\"Sum of arr(axis = 1) : \", np.sum(arr, axis = 1)) . Output would be: . Sum of arr : 279 Sum of arr(axis = 0) : [52 25 93 42 67] Sum of arr(axis = 1) : [120 75 84] . But notice how the vector of axis = 1 has been transposed to show as a row vector . We change that behaviour by adding a second argument to the sum() function: . print(\"\\nSum of arr (keepdimension is True): \\n\", np.sum(arr, axis = 1, keepdims = True)) . Output . Sum of arr (keepdimension is True): [[120] [ 75] [ 84]] . Looping over an Image and Grayscale . We can loop over individual elements in a matrix after knowing the shape of the matrix . The shape of the image is given as a tuple eg. (640, 540, 3) . | the last item of that tuple is the RGB spectrum (3 dimensions per pixel) | the first two items in the tuple is the actual size of the image | . for i in range(img.shape[1]): print() . In the above code we are looping over the rows. Therefore we are looping 640 times. Method 1 : Consider this method of converting image into greyscale: . import numpy as np import matplotlib.pyplot as plt from PIL import Image, ImageOps img = np.array(Image.open('B1.jpg')) print(img.shape) for i in range(img.shape[0]): for j in range(img.shape[1]): grey_value = 0 for k in range(img.shape[2]): grey_value += img[i,j,k] img[i,j,0] = int(grey_value/3) img2 = img[:,:,1] plt.figure(figsize=(8,8)) plt.imshow(img2) plt.show() . Also note how we removed the third (extra) dimensions using: . img2 = img[:,:,1] . This method uses averaging to find grayscale. However a slightly modified version is usually preferred: . Method 2: Accounting for Luminance Perception . import numpy as np import matplotlib.pyplot as plt from PIL import Image, ImageOps weight = [0.2989, 0.5870, 0.1140] img = np.array(Image.open('B1.jpg')) print(img.shape) for i in range(img.shape[0]): for j in range(img.shape[1]): grey_value = 0 for k in range(len(weight)): grey_value += (img[i,j,k]*weight[k]) img[i,j,0] = int(grey_value) img2 = img[:,:,1] plt.figure(figsize=(8,8)) plt.imshow(img2, cmap=plt.get_cmap(\"gray\")) plt.show() . Method 3: Simpler code using numpy.mean . from PIL import Image import numpy as np import matplotlib.pyplot as plt color_img = np.array(Image.open('B1.jpg')) / 255 img = np.mean(color_img, axis=2) plt.figure(figsize=(8,8)) plt.imshow(img, cmap=plt.get_cmap(\"gray\")) plt.show() . ",
    "url": "http://localhost:4000/numpy/#array-nomenclature",
    "relUrl": "/numpy/#array-nomenclature"
  },"16": {
    "doc": "Numpy",
    "title": "Built-in Numpy functions",
    "content": " ",
    "url": "http://localhost:4000/numpy/#built-in-numpy-functions",
    "relUrl": "/numpy/#built-in-numpy-functions"
  },"17": {
    "doc": "Numpy",
    "title": "Difference between dot, matmul, and *",
    "content": ". ",
    "url": "http://localhost:4000/numpy/#difference-between-dot-matmul-and-",
    "relUrl": "/numpy/#difference-between-dot-matmul-and-"
  },"18": {
    "doc": "Numpy",
    "title": "Plotting a pixel-wise histogram",
    "content": "img = np.array(Image.open('emma_stone.jpg')) img_flat = img.flatten() plt.hist(img_flat, bins=200, range=[0, 256]) plt.title(\"Number of pixels in each intensity value\") plt.xlabel(\"Intensity\") plt.ylabel(\"Number of pixels\") plt.show() . ",
    "url": "http://localhost:4000/numpy/#plotting-a-pixel-wise-histogram",
    "relUrl": "/numpy/#plotting-a-pixel-wise-histogram"
  },"19": {
    "doc": "Numpy",
    "title": "Reshaping Arrays",
    "content": "x = np.arange(4).reshape((2,2)) x &gt;&gt;array([[0, 1], [2, 3]]) . ",
    "url": "http://localhost:4000/numpy/#reshaping-arrays",
    "relUrl": "/numpy/#reshaping-arrays"
  },"20": {
    "doc": "Numpy",
    "title": "Transpose of a matrix",
    "content": "Simple transpose is done using the matrix.transpose() or matrix.T method (both are same). One of them is showed below: . # (refer matrix x in above example) np.transpose(x) array([[0, 2], [1, 3]]) . However the transpose function takes more arguments and this is important for 3D matrices. Note that if a 3D matrix say ‘A’ has shape (1,2,3), the result of transpose without specifying any extra argument will be (3,2,1) . x = np.ones((1, 2, 3)) np.transpose(x, (1, 0, 2)).shape &gt;&gt;(2, 1, 3) . Note. While declaring array as in np.ones(1,2,3). This can be interpreted in two ways: . | If we are printing the array in terminal we will read it as: there are 1 pages, 2 rows and 3 columns | If it’s an image, the shape will be 1 row, 2 coulmns and 3 will be for 3 RGB channels | . It’s important to realise that we only care about shapes of a matrix and our computation revolves around the shape tuple (1,2,3) irrespective of which is row or column. Develop a generalized version of matrix definitions!! . However, we will access each row/column starting from 0 as x[0,0,0] or x[1,1,1]. The second argument stands for the axes parameter. Axes are numbered as 0,1,2 . i.e. default configuration of axes is (0,1,2) for a 3D array and (0,1) for a 2D array . Therefore if we specify &lt;np.transpose(x,(1,0,2))&gt; we’re saying that we want the first two shapes interchanged. Remember that first two shapes are pages and rows. Hence, those two will interchange. ",
    "url": "http://localhost:4000/numpy/#transpose-of-a-matrix",
    "relUrl": "/numpy/#transpose-of-a-matrix"
  },"21": {
    "doc": "Numpy",
    "title": "Padding of Matrices",
    "content": "Padding is used to ensure overall image size does not reduce while run filters/convulutions on it . import numpy as np x = np.ones(3) y = np.pad(x, pad_width=1) y # Expected result # array([0., 1., 1., 1., 0.]) . ",
    "url": "http://localhost:4000/numpy/#padding-of-matrices",
    "relUrl": "/numpy/#padding-of-matrices"
  },"22": {
    "doc": "Numpy",
    "title": "newaxis method",
    "content": "ref: newaxis . This method can be used to convert a row vector to a column vector and at the same time add another dimension as shown below: . a = np.array([0,1,2]) print(a.shape) . Output: (3,) . Now lets do the newaxis modification: . c = (a[:, np.newaxis]) print(c) print(c.shape) . Output: . [[0] [1] [2]] (3, 1) . Therefore we can see that the vector has been rotated and another dimension has been added to the shape tuple . ",
    "url": "http://localhost:4000/numpy/#newaxis-method",
    "relUrl": "/numpy/#newaxis-method"
  },"23": {
    "doc": "Numpy",
    "title": "einsum",
    "content": "Refer to this document: einsum . ",
    "url": "http://localhost:4000/numpy/#einsum",
    "relUrl": "/numpy/#einsum"
  },"24": {
    "doc": "Numpy",
    "title": "Stacking rows using vstack",
    "content": "We can use this function to stack rows onto an exiting numpy array. in_arr1 = geek.array([ 1, 2, 3] ) in_arr2 = geek.array([ 4, 5, 6] ) # Stacking the two arrays vertically out_arr = geek.vstack((in_arr1, in_arr2)) print (out_arr) . Practically we can use this in a specific case. If we don’t know the number of rows we will be adding to a numpy array: . | We will define the array as a 0 row array | We then add rows as we progress using the vstack function | . word_array = np.array([]).reshape(0, maxlength) for message in messages: word_count = np.zeros((1, word_num)) for word in word_list: if word == \"yes\": word_count[0, word_dictionary[word]] += 1 word_array = np.vstack([word_array, word_count]) return word_array . ",
    "url": "http://localhost:4000/numpy/#stacking-rows-using-vstack",
    "relUrl": "/numpy/#stacking-rows-using-vstack"
  },"25": {
    "doc": "Numpy",
    "title": "Saving a numpy matrix in a text file",
    "content": "np.savetxt('./output/p06_sample_train_matrix', train_matrix[:100,:]) . ",
    "url": "http://localhost:4000/numpy/#saving-a-numpy-matrix-in-a-text-file",
    "relUrl": "/numpy/#saving-a-numpy-matrix-in-a-text-file"
  },"26": {
    "doc": "Numpy",
    "title": "Numpy",
    "content": ". | Before you Begin | Images and Arrays . | Image Operations . | Importing Images | Converting image to Greyscale | Plotting an image | . | Array Functions and Operations | Array Nomenclature . | sum() function in 1D | sum() in 2D along axes | Looping over an Image and Grayscale . | Method 1 : Consider this method of converting image into greyscale: | Method 2: Accounting for Luminance Perception | Method 3: Simpler code using numpy.mean | . | . | . | Built-in Numpy functions . | Difference between dot, matmul, and * | Plotting a pixel-wise histogram | Reshaping Arrays | Transpose of a matrix | Padding of Matrices | newaxis method | einsum | Stacking rows using vstack | Saving a numpy matrix in a text file | . | . ",
    "url": "http://localhost:4000/numpy/",
    "relUrl": "/numpy/"
  },"27": {
    "doc": "Home",
    "title": "Python Notes",
    "content": "Courseware . ",
    "url": "http://localhost:4000/#python-notes",
    "relUrl": "/#python-notes"
  },"28": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  }
}
