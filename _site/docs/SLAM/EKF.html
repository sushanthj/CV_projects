

<!DOCTYPE html>

<html lang="en-US">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">

  

  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

  <link rel="stylesheet" href="/assets/css/just-the-docs-default.css">

  

  
    <script type="text/javascript" src="/assets/js/vendor/lunr.min.js"></script>
  
  <script type="text/javascript" src="/assets/js/just-the-docs.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>EKF | Navigating Robotics</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="EKF" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Projects and assignments during my time in CMU" />
<meta property="og:description" content="Projects and assignments during my time in CMU" />
<link rel="canonical" href="http://localhost:4000/docs/SLAM/EKF.html" />
<meta property="og:url" content="http://localhost:4000/docs/SLAM/EKF.html" />
<meta property="og:site_name" content="Navigating Robotics" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="EKF" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Projects and assignments during my time in CMU","headline":"EKF","url":"http://localhost:4000/docs/SLAM/EKF.html"}</script>
<!-- End Jekyll SEO tag -->


  

</head>

<body>
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
    <symbol id="svg-link" viewBox="0 0 24 24">
      <title>Link</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link">
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
      </svg>
    </symbol>
    <symbol id="svg-search" viewBox="0 0 24 24">
      <title>Search</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search">
        <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
    </symbol>
    <symbol id="svg-menu" viewBox="0 0 24 24">
      <title>Menu</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
        <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </symbol>
    <symbol id="svg-arrow-right" viewBox="0 0 24 24">
      <title>Expand</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
    </symbol>
    <symbol id="svg-doc" viewBox="0 0 24 24">
      <title>Document</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file">
        <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>
      </svg>
    </symbol>
  </svg>

  <div class="side-bar">
    <div class="site-header">
      <a href="http://localhost:4000/" class="site-title lh-tight">
  Navigating Robotics

</a>
      <a href="#" id="menu-button" class="site-button">
        <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg>
      </a>
    </div>
    <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav">
      
        <ul class="nav-list"><li class="nav-list-item"><a href="http://localhost:4000/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="http://localhost:4000/intro/" class="nav-list-link">Building this Page</a></li><li class="nav-list-item"><a href="http://localhost:4000/planar_homography/" class="nav-list-link">Planar Homography</a></li><li class="nav-list-item"><a href="http://localhost:4000/3D_reconstruction/" class="nav-list-link">3D_reconstruction</a></li><li class="nav-list-item"><a href="http://localhost:4000/optical_flow/" class="nav-list-link">Optical Flow and Image Alignment</a></li><li class="nav-list-item"><a href="http://localhost:4000/constr_rrt/" class="nav-list-link">Constrained RRT</a></li><li class="nav-list-item"><a href="http://localhost:4000/spatial_pyramid_matching/" class="nav-list-link">Spatial Pyramid Matching for Scene Classification</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/DL_overview" class="nav-list-link">DL Overview</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/DL.html" class="nav-list-link">Deep Learning Starter</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/DL_old_arches.html" class="nav-list-link">DL Simple Architechtures</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/IDL1.html" class="nav-list-link">MLPs (IDL1)</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/IDL2.html" class="nav-list-link">Classifiers (IDL2)</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/IDL3.html" class="nav-list-link">Optimizers and Regularizers (IDL3)</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/IDL4.html" class="nav-list-link">Intro to CNNs</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/Resnet.html" class="nav-list-link">RESNET</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/Intro%20to%20ML" class="nav-list-link">Intro to ML</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/Intro%20to%20ML/Basics.html" class="nav-list-link">Basics</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Intro%20to%20ML/Linear_Regression.html" class="nav-list-link">Linear Regression</a></li></ul></li><li class="nav-list-item"><a href="http://localhost:4000/pytorch/" class="nav-list-link">Intro to Pytorch</a></li><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/SLAM" class="nav-list-link">SLAM</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Probability_review.html" class="nav-list-link">Recap on Probability</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Expectation_and_cov.html" class="nav-list-link">Expectation and Covariance</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Particle%20Filter_theory.html" class="nav-list-link">Particle Filters Theory</a></li><li class="nav-list-item  active"><a href="http://localhost:4000/docs/SLAM/EKF.html" class="nav-list-link active">EKF</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Non_linear_slam.html" class="nav-list-link">Least Squares SLAM</a></li></ul></li><li class="nav-list-item"><a href="http://localhost:4000/mrsd_proj/" class="nav-list-link">MRSD Capstone Project</a></li><li class="nav-list-item"><a href="http://localhost:4000/camera_model/" class="nav-list-link">Camera Models</a></li><li class="nav-list-item"><a href="http://localhost:4000/numpy/" class="nav-list-link">Numpy</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/Vision%20with%20C++" class="nav-list-link">Computer Vision using C++</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/Vision%20with%20C++/Eigen.html" class="nav-list-link">Linear Algebra in Eigen</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Vision%20with%20C++/Eigen_applied.html" class="nav-list-link">Eigen, OpenCV, and Images</a></li></ul></li></ul>

      
    </nav>
    <footer class="site-footer">
      This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.
    </footer>
  </div>
  <div class="main" id="top">
    <div id="main-header" class="main-header">
      
        <div class="search">
          <div class="search-input-wrap">
            <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Navigating Robotics" aria-label="Search Navigating Robotics" autocomplete="off">
            <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label>
          </div>
          <div id="search-results" class="search-results"></div>
        </div>
      
      
      
        <nav aria-label="Auxiliary" class="aux-nav">
          <ul class="aux-nav-list">
            
              <li class="aux-nav-list-item">
                <a href="//github.com/sushanthj" class="site-button"
                  
                >
                  Sushanth Jayanth's github
                </a>
              </li>
            
          </ul>
        </nav>
      
    </div>
    <div id="main-content-wrap" class="main-content-wrap">
      
        <nav aria-label="Breadcrumb" class="breadcrumb-nav">
            <ol class="breadcrumb-nav-list">
              
                <li class="breadcrumb-nav-list-item"><a href="http://localhost:4000/docs/SLAM">SLAM</a></li>
              
              <li class="breadcrumb-nav-list-item"><span>EKF</span></li>
            </ol>
          </nav>
        
      
      <div id="main-content" class="main-content" role="main">
        
          <details open="">
  <summary>
    Table of contents
  {: .text-delta }
  </summary>
<ol id="markdown-toc">
  <li><a href="#extended-kalman-filter" id="markdown-toc-extended-kalman-filter">Extended Kalman Filter</a></li>
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#robot-state" id="markdown-toc-robot-state">Robot State</a>    <ol>
      <li><a href="#motion-model" id="markdown-toc-motion-model">Motion Model</a>        <ol>
          <li><a href="#2d-robot-motion-model" id="markdown-toc-2d-robot-motion-model">2D Robot Motion Model</a></li>
          <li><a href="#using-motion-model-in-prediction" id="markdown-toc-using-motion-model-in-prediction">Using Motion Model in Prediction</a>            <ol>
              <li><a href="#noise-free-prediction" id="markdown-toc-noise-free-prediction">Noise Free Prediction</a></li>
              <li><a href="#prediction-with-uncertainty" id="markdown-toc-prediction-with-uncertainty">Prediction with Uncertainty</a></li>
            </ol>
          </li>
        </ol>
      </li>
      <li><a href="#sensor-model" id="markdown-toc-sensor-model">Sensor Model</a></li>
    </ol>
  </li>
  <li><a href="#ekf-algorithm" id="markdown-toc-ekf-algorithm">EKF Algorithm</a>    <ol>
      <li><a href="#algorithm-overview" id="markdown-toc-algorithm-overview">Algorithm Overview</a></li>
      <li><a href="#setup-and-initialization" id="markdown-toc-setup-and-initialization">Setup and Initialization</a>        <ol>
          <li><a href="#landmark-initialization---finding-landmark-pose-covariance" id="markdown-toc-landmark-initialization---finding-landmark-pose-covariance">Landmark Initialization - Finding Landmark Pose Covariance</a></li>
        </ol>
      </li>
      <li><a href="#main-loop-of-algorithm" id="markdown-toc-main-loop-of-algorithm">Main Loop of Algorithm</a>        <ol>
          <li><a href="#prediction-step" id="markdown-toc-prediction-step">Prediction Step</a>            <ol>
              <li><a href="#finding-the-covariance" id="markdown-toc-finding-the-covariance">Finding the Covariance</a></li>
            </ol>
          </li>
          <li><a href="#prediction-step-code" id="markdown-toc-prediction-step-code">Prediction Step Code</a></li>
          <li><a href="#update-step---a-comparison-step" id="markdown-toc-update-step---a-comparison-step">Update Step - A comparison step</a>            <ol>
              <li><a href="#measurement-model-definition" id="markdown-toc-measurement-model-definition">Measurement Model Definition</a></li>
              <li><a href="#using-the-measurement-model" id="markdown-toc-using-the-measurement-model">Using the Measurement Model</a></li>
              <li><a href="#deriving-h_t" id="markdown-toc-deriving-h_t">Deriving H_t</a></li>
            </ol>
          </li>
          <li><a href="#update-step-in-code" id="markdown-toc-update-step-in-code">Update Step in Code</a></li>
        </ol>
      </li>
      <li><a href="#overview-of-implementation" id="markdown-toc-overview-of-implementation">Overview of Implementation</a>        <ol>
          <li><a href="#visual-interpretation" id="markdown-toc-visual-interpretation">Visual Interpretation</a></li>
        </ol>
      </li>
      <li><a href="#detailed-notes-and-derivation" id="markdown-toc-detailed-notes-and-derivation">Detailed Notes and Derivation</a></li>
    </ol>
  </li>
</ol>

</details>
      <h1 id="extended-kalman-filter">
        
        
          <a href="#extended-kalman-filter" class="anchor-heading" aria-labelledby="extended-kalman-filter"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Extended Kalman Filter
        
        
      </h1>
    

<p>We’ll be using EKF to solve Non-linear online SLAM.</p>

<p>Note. Full SLAM = no marginalization (i.e. we optimize over all robot states). Online SLAM is
what we do in EKF where we only care about the previous robot state and marginalize out all
the older states.</p>

<p>Here, marginalization is just a way of integrating probability density functions to get
a certainty in pose estimates of past poses. This works fine if the pose estimates were good
to begin with. This also cannot handle anything like loop closures.</p>

<p class="btn fs-5 mb-4 mb-md-0"><a href="https://github.com/sushanthj/SLAM-and-Robot-Autonomy/blob/main/SLAM/EKF/SLAM_Assignment_2.pdf">Detailed write-up</a></p>
      <h1 id="introduction">
        
        
          <a href="#introduction" class="anchor-heading" aria-labelledby="introduction"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Introduction
        
        
      </h1>
    

<p>Here we’ll use landmarks already known to us from the dataset (landmark poses) in 2D space.
Hence our localization would also be in 2D.</p>

<p>The below image shows the robot poses and the landmarks (in green).</p>

<p><img src="/images/SLAM/EKF/plot.png" alt="" /></p>

<p>Since we localize in 2D our robot state space would also need to be in 2D. The robot’s pose can
therefore be just <em>x, y, and yaw</em>.</p>

<p>Similar to the particle filter, here too we will have two steps in the algorithm:</p>
<ul>
  <li>Prediction Step - <strong>uses motion model</strong></li>
  <li>Update Step - <strong>uses sensor model</strong></li>
</ul>

<p>However, the update step in this case will depend on which landmarks we observe and will only
update the pose estimates of the robot and those landmarks alone.</p>

<p>The sensor model uses a laser rangefinder to give the landmark position in robot frame (which
is later converted into global coordinates)</p>
      <h1 id="robot-state">
        
        
          <a href="#robot-state" class="anchor-heading" aria-labelledby="robot-state"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Robot State
        
        
      </h1>
    

<p>Since we localize both <strong>landmarks</strong> and the <strong>robot pose</strong>, the state vector must contain
both information.</p>

<p><img src="/images/SLAM/EKF/state_vector.png" alt="" /></p>

<p>The above state vector captures robot pose and landmark position in <strong>global coordinates</strong>.
Robot pose has three variables (x,y,theta) and landmark position has two variables (x,y)
for each landmark.</p>

<p>This results in a <strong>large state vector which is one of the drawbacks of EKF</strong>.</p>
      <h2 id="motion-model">
        
        
          <a href="#motion-model" class="anchor-heading" aria-labelledby="motion-model"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Motion Model
        
        
      </h2>
    

<p>Previously, we used an odometry motion model in particle filters. This model is used here only
for comparison and explanation and <em>we will be using something slightly different.</em></p>

<p><img src="/images/SLAM/EKF/pf_motion_model.png" alt="" /></p>

<p>Generally there are two forms of expressions for motion models:</p>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th style="text-align: left">Closed form calculation</th>
      <th style="text-align: left">Sampling</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Calculates the robot’s pose as a probability using the previous state as a prior</td>
      <td style="text-align: left">Calculates multiple poses where the robot might land based on the noise in model</td>
    </tr>
    <tr>
      <td style="text-align: left"><img src="/images/SLAM/EKF/closed_form.png" alt="" /></td>
      <td style="text-align: left"><img src="/images/SLAM/EKF/sampling_motion.png" alt="" /></td>
    </tr>
  </tbody>
</table></div>

<p>In Particle Filters, we needed estimates of the where each particle would land and we therefore
had to use sampling. However, for EKF we need estimates of how noisy the estimated robot pose
would be. <strong>Hence, we will kinda be using a closed form type.</strong></p>
      <h3 id="2d-robot-motion-model">
        
        
          <a href="#2d-robot-motion-model" class="anchor-heading" aria-labelledby="2d-robot-motion-model"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2D Robot Motion Model
        
        
      </h3>
    

<ul>
  <li>The robot will be constrained to only move in one axis (x-axis) shown as <em>d_t</em> in the robot’s
body frame. However, it will be allowed to rotate along it’s central axis by <em>alpha</em>.</li>
  <li>We will also add noise to motion in all three axis as <em>e_x, e_y, and e_alpha</em></li>
</ul>

<p><img src="/images/SLAM/EKF/motion_model.png" alt="" /></p>
      <h3 id="using-motion-model-in-prediction">
        
        
          <a href="#using-motion-model-in-prediction" class="anchor-heading" aria-labelledby="using-motion-model-in-prediction"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Using Motion Model in Prediction
        
        
      </h3>
    

<p>Here we mathematically define the prediction step used in EKF</p>
      <h4 id="noise-free-prediction">
        
        
          <a href="#noise-free-prediction" class="anchor-heading" aria-labelledby="noise-free-prediction"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Noise Free Prediction
        
        
      </h4>
    

<p><img src="/images/SLAM/EKF/noise_free_motion_pred.png" alt="" /></p>
      <h4 id="prediction-with-uncertainty">
        
        
          <a href="#prediction-with-uncertainty" class="anchor-heading" aria-labelledby="prediction-with-uncertainty"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Prediction with Uncertainty
        
        
      </h4>
    

<p>We will now represent the prediction step as a non-linear function g(x,u) with some added noise</p>

<p><img src="/images/SLAM/EKF/motion_pred_with_unc_1.png" alt="" /></p>

<p><img src="/images/SLAM/EKF/motion_pred_with_unc_2.png" alt="" /></p>
      <h2 id="sensor-model">
        
        
          <a href="#sensor-model" class="anchor-heading" aria-labelledby="sensor-model"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Sensor Model
        
        
      </h2>
    

<p>Given the range r and bearing β readings from a laser rangefinder, we can estimate the location of landmarks
in the global frame given a known robot state. We will use this as our measurement prediction model
h(p_t, β, r)</p>

<p>Therefore the landmark predictions are mathematically defined as:</p>

<p><img src="/images/SLAM/EKF/landmark_pred_1.png" alt="" /></p>

<p>The uncertainty is modelled separately as white noise (normally distributed with zero mean)</p>

<p><img src="/images/SLAM/EKF/landmark_pred_2.png" alt="" /></p>
      <h1 id="ekf-algorithm">
        
        
          <a href="#ekf-algorithm" class="anchor-heading" aria-labelledby="ekf-algorithm"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> EKF Algorithm
        
        
      </h1>
    

<p>The main function of the EKF algorithm helps decrease the uncertainty in our state vector
(robot and landmark poses). Firstly, lets understand how the uncertainty in poses is captured.</p>

<p>Remember the <a href="#motion-model">motion model</a> and <a href="#sensor-model">sensor model</a>.
We saw that noise was included in both cases. The motion model noise is called <strong>control noise</strong>
or process noise and the sensor model noise is called <strong>measurement noise</strong></p>

<p>Since both control and measurement noise affects the robot state, it is easy to maintain a
combined covariance matrix P . The below equation shows how the state vector relates to the
mean and covariance matrices.</p>

<p><img src="/images/SLAM/EKF/cov_intro.png" alt="" /></p>

<p><img src="/images/SLAM/EKF/landmark_state_vector.jpeg" alt="" /></p>

<p>In the EKF algorithm we will update parts of the above covariance matrix in different steps:</p>
<ul>
  <li>The above image shows mean and covariance. <span style="color:black"> We find the mean using the non-linear functions of the motion and sensor model </span></li>
  <li><span style="color:black"> Given Control Reading </span> : we update the Σ_xx primarily plus the first row and first column elements since they depend on x_t</li>
  <li><span style="color:black"> Given Sensor Reading  </span> : we update the whole covariance matrix (assuming we see all landmarks in each sensor reading)</li>
</ul>
      <h2 id="algorithm-overview">
        
        
          <a href="#algorithm-overview" class="anchor-heading" aria-labelledby="algorithm-overview"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Algorithm Overview
        
        
      </h2>
    

<p><img src="/images/SLAM/EKF/algo.png" alt="" /></p>
      <h2 id="setup-and-initialization">
        
        
          <a href="#setup-and-initialization" class="anchor-heading" aria-labelledby="setup-and-initialization"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Setup and Initialization
        
        
      </h2>
    

<p>Previously we saw the following image of what our state vector and covariance matrix would look</p>

<p><em>Note:</em>
<em>state_vector = µ</em></p>

<p><em>covariance = Σ</em></p>

<p><img src="/images/SLAM/EKF/cov_intro.png" alt="" /></p>

<p><img src="/images/SLAM/EKF/landmark_state_vector.jpeg" alt="" /></p>

<p>The same structre is followed in code where we will have <strong>X</strong> as our state vector and <strong>P</strong> as
our covariance matrix</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># Generate variance from standard deviation
</span>  <span class="n">sig_x2</span> <span class="o">=</span> <span class="n">sig_x</span><span class="o">**</span><span class="mi">2</span>
  <span class="n">sig_y2</span> <span class="o">=</span> <span class="n">sig_y</span><span class="o">**</span><span class="mi">2</span>
  <span class="n">sig_alpha2</span> <span class="o">=</span> <span class="n">sig_alpha</span><span class="o">**</span><span class="mi">2</span>
  <span class="n">sig_beta2</span> <span class="o">=</span> <span class="n">sig_beta</span><span class="o">**</span><span class="mi">2</span>
  <span class="n">sig_r2</span> <span class="o">=</span> <span class="n">sig_r</span><span class="o">**</span><span class="mi">2</span>

  <span class="c1"># Open data file and read the initial measurements
</span>  <span class="n">data_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"../data/data.txt"</span><span class="p">)</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">data_file</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span>
  <span class="n">fields</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'[</span><span class="se">\t</span><span class="s"> ]'</span><span class="p">,</span> <span class="n">line</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="s">"""
  The data file is extracted as arr and is given to init_landmarks below

  The data file has 2 types of entries:
  1. landmarks [β_1 r_1 β_2 r_2 · · · ], where β_i , r_i correspond to landmark
  2. control inputs in form of [d, alpha] (d = translation along x-axis)
  """</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">])</span>
  <span class="n">measure</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="c1"># Setup control and measurement covariance
</span>  <span class="n">control_cov</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">([</span><span class="n">sig_x2</span><span class="p">,</span> <span class="n">sig_y2</span><span class="p">,</span> <span class="n">sig_alpha2</span><span class="p">])</span>
  <span class="n">measure_cov</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">([</span><span class="n">sig_beta2</span><span class="p">,</span> <span class="n">sig_r2</span><span class="p">])</span>

  <span class="c1"># Setup the initial pose vector and pose uncertainty
</span>  <span class="c1"># pose vector is initialized to zero
</span>  <span class="n">pose</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
  <span class="n">pose_cov</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">0.02</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.02</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.1</span><span class="o">**</span><span class="mi">2</span><span class="p">])</span>

  <span class="s">"""
  measure = all landmarks
  measure_cov = known sensor covariance
  pose = initialized to (0,0)
  pose_cov = how much we trust motion model = fixed
  """</span>
  <span class="n">k</span><span class="p">,</span> <span class="n">landmark</span><span class="p">,</span> <span class="n">landmark_cov</span> <span class="o">=</span> <span class="n">init_landmarks</span><span class="p">(</span><span class="n">measure</span><span class="p">,</span> <span class="n">measure_cov</span><span class="p">,</span> <span class="n">pose</span><span class="p">,</span>
                                              <span class="n">pose_cov</span><span class="p">)</span> <span class="c1"># basically H_t in for-loop of pg 204
</span>  <span class="k">print</span><span class="p">(</span><span class="s">"Orig K is"</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

  <span class="c1"># Setup state vector X by stacking pose and landmark states
</span>  <span class="c1"># X = [x_t, y_t, thetha_t, landmark1(range), landmark1(bearing), landmark2(range)...]
</span>  <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">pose</span><span class="p">,</span> <span class="n">landmark</span><span class="p">))</span>

  <span class="c1"># Setup covariance matrix P by expanding pose and landmark covariances
</span>  <span class="s">"""
  - The covariance matrix for a state vector = [x,y,thetha] would be 3x3
  - However, since we also add landmarks into the state vector, we need to add that as well
  - Since there are 2*k landmarks, we create a new matrix encapsulating pose_cov and landmark_cov

  - this new cov matrix (constructed by np.block) is:

      [[pose_cov,        0     ],
        [    0,     landmark_cov]]

  """</span>
  <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">block</span><span class="p">([[</span><span class="n">pose_cov</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">landmark_cov</span><span class="p">]])</span>

  <span class="k">print</span><span class="p">(</span><span class="s">"Init covariance </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nb">round</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>
      <h3 id="landmark-initialization---finding-landmark-pose-covariance">
        
        
          <a href="#landmark-initialization---finding-landmark-pose-covariance" class="anchor-heading" aria-labelledby="landmark-initialization---finding-landmark-pose-covariance"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Landmark Initialization - Finding Landmark Pose Covariance
        
        
      </h3>
    

<p>In the above code of setting up the state vector and covariance matrix, we see the following
lines:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">k</span><span class="p">,</span> <span class="n">landmark</span><span class="p">,</span> <span class="n">landmark_cov</span> <span class="o">=</span> <span class="n">init_landmarks</span><span class="p">(</span><span class="n">measure</span><span class="p">,</span> <span class="n">measure_cov</span><span class="p">,</span> <span class="n">pose</span><span class="p">,</span>
                                              <span class="n">pose_cov</span><span class="p">)</span> <span class="c1"># basically H_t in for-loop of pg 204
</span>                                                        <span class="c1"># of probabalistic robotics
</span>
<span class="c1"># covariance matrix
</span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">block</span><span class="p">([[</span><span class="n">pose_cov</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">landmark_cov</span><span class="p">]])</span>
</code></pre></div></div>

<p>Here we see that the function init_landmarks is giving us the <strong>landmark_cov and k</strong>
(k = no. of landmarks). Let’s take a look at this function to see it’s working.</p>

<p>We will need to find the covariance of the landmarks by using the <a href="#sensor-model">Sensor Model</a></p>

<p><img src="/images/SLAM/EKF/landmark_cov.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">init_landmarks</span><span class="p">(</span><span class="n">init_measure</span><span class="p">,</span> <span class="n">init_measure_cov</span><span class="p">,</span> <span class="n">init_pose</span><span class="p">,</span> <span class="n">init_pose_cov</span><span class="p">):</span>
    <span class="s">'''
    NOTE: Here we predict where the landmark may be, based on bearing and range sensor readings

    1. Number of landmarks (k)
    2. landmark states (just position (2k,1)) which will get stacked onto
       robot pose
    3. Covariance of landmark pose estimations (see theory)

    input1 init_measure    :  Initial measurements of form (beta0, l0, beta1,...) (2k,1)
    input2 init_measure_cov:  Initial covariance matrix (2, 2) per landmark given parameters.
    input3 init_pose       :  Initial pose vector of shape (3, 1).
    input4 init_pose_cov   :  Initial pose covariance of shape (3, 3) given parameters.

    return1 k              : Number of landmarks.
    return2 landmarks      : Numpy array of shape (2k, 1) for the state.
    return3 landmarks_cov  : Numpy array of shape (2k, 2k) for the uncertainty.
    '''</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">init_measure</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">landmark</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">landmark_cov</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">))</span>

    <span class="n">x_t</span> <span class="o">=</span> <span class="n">init_pose</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y_t</span> <span class="o">=</span> <span class="n">init_pose</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">theta_t</span> <span class="o">=</span> <span class="n">init_pose</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># to find the covaraince of all landmark poses, we need to iterate over each landmark
</span>    <span class="c1"># and start filling in landmark_cov array initialized above. (we'll fill in diagonal
</span>    <span class="c1"># components only)
</span>    <span class="k">for</span> <span class="n">l_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="c1"># l_i is the i'th landmark
</span>        <span class="c1"># init_measure.shape = (2k,1)
</span>        <span class="n">beta</span> <span class="o">=</span> <span class="n">init_measure</span><span class="p">[</span><span class="n">l_i</span><span class="o">*</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">l_range</span> <span class="o">=</span> <span class="n">init_measure</span><span class="p">[</span><span class="n">l_i</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># need to find landmark location in global coords (l_x, l_y) to find H_l
</span>        <span class="n">l_x</span> <span class="o">=</span> <span class="n">x_t</span> <span class="o">+</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">l_range</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="o">+</span><span class="n">theta_t</span><span class="p">)))</span>
        <span class="n">l_y</span> <span class="o">=</span> <span class="n">y_t</span> <span class="o">+</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">l_range</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="o">+</span><span class="n">theta_t</span><span class="p">)))</span>

        <span class="n">landmark</span><span class="p">[</span><span class="n">l_i</span><span class="o">*</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_x</span>
        <span class="n">landmark</span><span class="p">[</span><span class="n">l_i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_y</span>

        <span class="c1"># Note, L here is the derivative of (l_x,l_y) vector (sensor model) w.r.t beta and theta
</span>        <span class="c1"># G_l is the derivative of same sensor model w.r.t state varialbes (x,y,theta)
</span>        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="n">l_range</span><span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="o">+</span><span class="n">theta_t</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="o">+</span><span class="n">theta_t</span><span class="p">))],</span>
                      <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">l_range</span><span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="o">+</span><span class="n">theta_t</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="o">+</span><span class="n">theta_t</span><span class="p">))]])</span>

        <span class="c1"># G_l represents the robot pose aspect of landmark measurement
</span>        <span class="c1"># therefore when measuring covariance, it will use robot pose covariance
</span>        <span class="n">G_l</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="n">l_range</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_t</span> <span class="o">+</span> <span class="n">beta</span><span class="p">))],</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">l_range</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_t</span> <span class="o">+</span> <span class="n">beta</span><span class="p">))]])</span>

        <span class="c1"># See theory, L below was derived w.r.t to measurement. Therefore,
</span>        <span class="c1"># during covariance calculation it will use measurement_covariance
</span>        <span class="c1"># Similarly, G defined w.r.t state variables (x,y,theta) therefore uses pose_covariance
</span>        <span class="n">pred_landmark_cov</span> <span class="o">=</span> <span class="p">(</span><span class="n">G_l</span> <span class="o">@</span> <span class="n">init_pose_cov</span> <span class="o">@</span> <span class="n">G_l</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">L</span> <span class="o">@</span> <span class="n">init_measure_cov</span> <span class="o">@</span> <span class="n">L</span><span class="p">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">assert</span><span class="p">(</span><span class="n">pred_landmark_cov</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

        <span class="n">landmark_cov</span><span class="p">[</span><span class="n">l_i</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span><span class="n">l_i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">l_i</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span><span class="n">l_i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred_landmark_cov</span>

    <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">landmark</span><span class="p">,</span> <span class="n">landmark_cov</span>
</code></pre></div></div>
      <h2 id="main-loop-of-algorithm">
        
        
          <a href="#main-loop-of-algorithm" class="anchor-heading" aria-labelledby="main-loop-of-algorithm"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Main Loop of Algorithm
        
        
      </h2>
    

<p>Once we have setup our state vector and covariance matrix, we start the series of
<strong>prediction and update steps</strong>. This is done in code as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Core loop: sequentially process controls and measurements
</span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data_file</span><span class="p">:</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'[</span><span class="se">\t</span><span class="s"> ]'</span><span class="p">,</span> <span class="n">line</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">])</span>

    <span class="c1"># Control
</span>    <span class="k">if</span> <span class="n">arr</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s">: Predict step'</span><span class="p">)</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">control</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="n">d</span><span class="p">],</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]])</span>

        <span class="n">X_pre</span><span class="p">,</span> <span class="n">P_pre</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">control</span><span class="p">,</span> <span class="n">control_cov</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="c1"># Measurement
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s">: Update step'</span><span class="p">)</span>
        <span class="n">measure</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">X_pre</span><span class="p">,</span> <span class="n">P_pre</span><span class="p">,</span> <span class="n">measure</span><span class="p">,</span> <span class="n">measure_cov</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">last_X</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>
      <h3 id="prediction-step">
        
        
          <a href="#prediction-step" class="anchor-heading" aria-labelledby="prediction-step"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Prediction Step
        
        
      </h3>
    

<p><img src="/images/SLAM/EKF/predict_graph.png" alt="" /></p>

<p>After we initialize the state vector and covariance matrix, we can then proceed to the next
time step in our data file. At this stage we will be making predictions and updating the state
vector.</p>
      <h4 id="finding-the-covariance">
        
        
          <a href="#finding-the-covariance" class="anchor-heading" aria-labelledby="finding-the-covariance"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Finding the Covariance
        
        
      </h4>
    
<ul>
  <li>Step 4 of the <a href="#the-algorithm">EKF Algorithm</a> is the <strong>predicted covariance</strong> based on
some odometry reading.</li>
  <li>However, this predicted covariance has two parts. Robot pose covariance and Landmark covariance</li>
  <li>Landmark covariance was initialized in the previous step. Hence, <span style="color:blue">
only the robot pose covariance and any covariance associated with robot pose will be updated.
</span> This translates to only the first row and first column of the covariance matrix
getting updated. See <a href="#setup-and-initialization">cov matrix</a> for why first row and column</li>
</ul>

<p><img src="/images/SLAM/EKF/pose_cov.png" alt="" /></p>
      <h3 id="prediction-step-code">
        
        
          <a href="#prediction-step-code" class="anchor-heading" aria-labelledby="prediction-step-code"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Prediction Step Code
        
        
      </h3>
    

<p>Now, we will only be predicting the robot pose <span style="color:black"> (landmarks are initialized once and only updated
in sensor measurements i.e. update step)</span></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">control</span><span class="p">,</span> <span class="n">control_cov</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="s">'''
    NOTE: Here we predict only the robot's new state (new state's mean and covariance)

    \param X State vector of shape (3 + 2k, 1) stacking pose and landmarks.
    \param P Covariance matrix of shape (3 + 2k, 3 + 2k) for X.
    \param control Control signal of shape (2, 1) in the polar space that moves the robot.
    \param control_cov Control covariance shape (3, 3) in the (x, y, theta) space.
    \param k Number of landmarks.

    </span><span class="se">\r</span><span class="s">eturn X_pre Predicted X state of shape (3 + 2k, 1).
    </span><span class="se">\r</span><span class="s">eturn P_pre Predicted P covariance of shape (3 + 2k, 3 + 2k).
    '''</span>
    <span class="c1"># TODO: Predict new position (mean) using control inputs (only geometrical, no cov here)
</span>    <span class="n">theta_curr</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">d_t</span> <span class="o">=</span> <span class="n">control</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># control input in robot's local frame's x-axis
</span>    <span class="n">alpha_t</span> <span class="o">=</span> <span class="n">control</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">P_pred</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">pos_cov</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">X_pred</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># update only robot pose (not landmark pose)
</span>    <span class="n">X_pred</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">d_t</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_curr</span><span class="p">))</span>
    <span class="n">X_pred</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">d_t</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_curr</span><span class="p">))</span>
    <span class="n">X_pred</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha_t</span><span class="p">)</span>

    <span class="n">X_pred</span> <span class="o">=</span> <span class="n">X_pred</span> <span class="o">+</span> <span class="n">X</span>

    <span class="c1"># TODO: Predict new uncertainity (covariance) using motion model noise, find G_t and R_t
</span>    <span class="c1"># NOTE: G_t needs to be mulitplied with P viz of shape (3 + 2k, 3+ 2k), because it has
</span>    <span class="c1"># pose and measurement cov. IN THIS STEP OF PREDICTION WE ONLY UPDATE POSE COV
</span>    <span class="c1"># Therefore G_t and R_t can be 3x3 (3 variables in state vector)
</span>
    <span class="n">G_t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="n">d_t</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_curr</span><span class="p">))],</span>
                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">d_t</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_curr</span><span class="p">))],</span>
                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                <span class="mi">1</span>               <span class="p">]])</span>

    <span class="n">rotation_matrix_z</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_curr</span><span class="p">)),</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_curr</span><span class="p">)),</span> <span class="mi">0</span><span class="p">],</span>
                                  <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_curr</span><span class="p">)),</span>  <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_curr</span><span class="p">)),</span> <span class="mi">0</span><span class="p">],</span>
                                  <span class="p">[</span>           <span class="mi">0</span><span class="p">,</span>                            <span class="mi">0</span><span class="p">,</span>            <span class="mi">1</span><span class="p">]])</span>

    <span class="n">pose_pred_cov</span> <span class="o">=</span> <span class="p">(</span><span class="n">G_t</span> <span class="o">@</span> <span class="n">pos_cov</span> <span class="o">@</span> <span class="n">G_t</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="p">(</span><span class="n">rotation_matrix_z</span> <span class="o">@</span> <span class="n">control_cov</span> <span class="o">@</span> <span class="n">rotation_matrix_z</span><span class="p">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># update just the new predicted covariance in robot pose, measurement pose is left untouched
</span>    <span class="n">P_pred</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">pose_pred_cov</span>

    <span class="k">return</span> <span class="n">X_pred</span><span class="p">,</span> <span class="n">P_pred</span>
</code></pre></div></div>
      <h3 id="update-step---a-comparison-step">
        
        
          <a href="#update-step---a-comparison-step" class="anchor-heading" aria-labelledby="update-step---a-comparison-step"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Update Step - A comparison step
        
        
      </h3>
    

<p><img src="/images/SLAM/EKF/update_graph.png" alt="" /></p>

<p>The prediction step helps us get an esitmate of where the robot and landmarks should be.</p>

<p>Using this estimate of where the robot and landmarks are located, we check the difference
between what sensor reading we expect to get at these estimated poses
<strong>(predicted sensor reading)</strong> and where the robot actually is <strong>(actual sensor reading)</strong></p>

<p>The method to predict a sensor reading <strong>given an estimated robot and landmark pose</strong> is by
defining a measurement model.</p>
      <h4 id="measurement-model-definition">
        
        
          <a href="#measurement-model-definition" class="anchor-heading" aria-labelledby="measurement-model-definition"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Measurement Model Definition
        
        
      </h4>
    

<p>Using state vector p_t (contains robot pose and landmark) for the j’th landmark, the bearing <strong>β</strong>
and range <strong>r</strong> estimate for the j’th landmark is predicted as <strong>h(p_t , j)</strong></p>

<p>Where h(p_t , j) = measurement model</p>

<p><img src="/images/SLAM/EKF/meas_model.png" alt="" /></p>
      <h4 id="using-the-measurement-model">
        
        
          <a href="#using-the-measurement-model" class="anchor-heading" aria-labelledby="using-the-measurement-model"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Using the Measurement Model
        
        
      </h4>
    

<p>The comparison step happens in the final parts of the algorithm shown below:</p>

<p><img src="/images/SLAM/EKF/H_t.png" alt="" /></p>

<p><img src="/images/SLAM/EKF/update_1.png" alt="" /></p>

<p>Here we see that we compare the predicted covariance Σ with H_t. Specifically the second
equation above is clear in it’s purpose and is explained below:</p>

<ul>
  <li>µ = µ̄ + K(z - ẑ)</li>
  <li>The RHS part of this equation shows how we compare the real sensor reading <strong>z</strong> and the
predicted sensor reading <strong>ẑ</strong></li>
  <li>The variable <strong>K</strong> then acts as a scaling factor only</li>
</ul>
      <h4 id="deriving-h_t">
        
        
          <a href="#deriving-h_t" class="anchor-heading" aria-labelledby="deriving-h_t"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Deriving H_t
        
        
      </h4>
    

<p><img src="/images/SLAM/EKF/jac_H.png" alt="" /></p>
      <h3 id="update-step-in-code">
        
        
          <a href="#update-step-in-code" class="anchor-heading" aria-labelledby="update-step-in-code"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Update Step in Code
        
        
      </h3>
    

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">X_pre</span><span class="p">,</span> <span class="n">P_pre</span><span class="p">,</span> <span class="n">measure</span><span class="p">,</span> <span class="n">measure_cov</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="s">'''
    NOTE: Using predicted landmark &amp; robot pose, we emulate our sensor reading using the sensor model

    \param X_pre Predicted state vector of shape (3 + 2k, 1) from the predict step.
    \param P_pre Predicted covariance matrix of shape (3 + 2k, 3 + 2k) from the predict step.
    \param measure Measurement signal of shape (2k, 1).
    \param measure_cov Measurement covariance of shape (2, 2) per landmark given the parameters.
    \param k Number of landmarks.

    </span><span class="se">\r</span><span class="s">eturn X Updated X state of shape (3 + 2k, 1).
    </span><span class="se">\r</span><span class="s">eturn P Updated P covariance of shape (3 + 2k, 3 + 2k).

    Since we have a measurement, we will have to update both pose and measure covariances, i.e.
    the entire P_pre will be updated.

    Here we use the H_p and H_l described in the theory section. H_l and H_p will be combined
    to form H_t (the term in the EKF Algorithm in Probablistic Robotics). This H_t term
    will be defined for each landmark and stored in a massive matrix

    Q viz measurement covariance will need to be added to the H_t of each landmark, therefore
    it too will also be stored in a huge diagonal matrix
    '''</span>
    <span class="c1"># Q needs to be added to (Ht @ P_pre @ (Ht.T)) = (2*k, 2*k), therefore must be same shape
</span>    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">))</span>

    <span class="c1"># stack all predicted measurements into one large vector
</span>    <span class="n">z_t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># H_t as discussed above will be a large diagonal matrix where we'll stack H_p and H_l
</span>    <span class="c1"># side-by-side horizontally (making H_t 2x5 for each landmark). This will then be stacked
</span>    <span class="c1"># vertically, but again as a diagonal matrix.
</span>    <span class="c1"># H_t.T will also be multiplied with P_pre (3+2k, 3+2k). Therefore this needs to
</span>    <span class="c1"># also have 3+2k columns therefore the other dimensions should be 2k rows since
</span>    <span class="c1"># (H_p concat with H_l) = 2x5. Therefore, final H_t shape = 2k,3+2k
</span>    <span class="n">H_t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">)))</span>

    <span class="c1"># iterate through every measurement, assuming every measurement captures every landmark
</span>    <span class="n">num_measurements</span> <span class="o">=</span> <span class="n">k</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_measurements</span><span class="p">):</span>
        <span class="c1"># since we have a predicted pose already X_pre[0:3] we'll use that as our
</span>        <span class="c1"># linearization point
</span>
        <span class="c1"># define the predicted pose of robot and landmark in global frame
</span>        <span class="n">pos_x</span> <span class="o">=</span> <span class="n">X_pre</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># robot pose_x in global frame
</span>        <span class="n">pos_y</span> <span class="o">=</span> <span class="n">X_pre</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># robot pose_y in global frame
</span>        <span class="n">pos_theta</span> <span class="o">=</span> <span class="n">X_pre</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#  bearing in global frame
</span>        <span class="n">l_x</span> <span class="o">=</span> <span class="n">X_pre</span><span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># landmark i in global frame
</span>        <span class="n">l_y</span> <span class="o">=</span> <span class="n">X_pre</span><span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># landmark i in global frame
</span>
        <span class="c1"># convert predicted poses to local frame
</span>        <span class="n">l_x_offset</span> <span class="o">=</span> <span class="n">l_x</span> <span class="o">-</span> <span class="n">pos_x</span>
        <span class="n">l_y_offset</span> <span class="o">=</span> <span class="n">l_y</span> <span class="o">-</span> <span class="n">pos_y</span>

        <span class="c1"># use predicted pose of robot and landmark to get predicted measurements
</span>        <span class="n">i_bearing</span> <span class="o">=</span> <span class="n">warp2pi</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">l_y_offset</span><span class="p">,</span> <span class="n">l_x_offset</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos_theta</span><span class="p">)</span> <span class="c1"># bearing of i-th l
</span>        <span class="n">i_range</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">l_x_offset</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">l_y_offset</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># range of i-th landmark
</span>        <span class="n">z_t</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_bearing</span>
        <span class="n">z_t</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_range</span>

        <span class="c1"># Jacobian of measurement function (h(β,r) in theory) w.r.t pose (x,y,theta)
</span>        <span class="c1"># Note here we define h(β,r), whereas in theory it is h(r,β), hence rows are interchanged
</span>        <span class="n">H_p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[(</span><span class="o">-</span><span class="n">l_x_offset</span><span class="o">/</span><span class="n">i_range</span><span class="p">)</span>    <span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">l_y_offset</span><span class="o">/</span><span class="n">i_range</span><span class="p">),</span>       <span class="mi">0</span><span class="p">],</span>
                        <span class="p">[(</span><span class="n">l_y_offset</span><span class="o">/</span><span class="p">(</span><span class="n">i_range</span><span class="o">**</span><span class="mi">2</span><span class="p">)),</span> <span class="p">(</span><span class="o">-</span><span class="n">l_x_offset</span><span class="o">/</span><span class="p">(</span><span class="n">i_range</span><span class="o">**</span><span class="mi">2</span><span class="p">)),</span> <span class="o">-</span><span class="mi">1</span><span class="p">],],</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Note here we define h(β,r)
</span>        <span class="n">H_l</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[(</span><span class="n">l_x_offset</span><span class="o">/</span><span class="n">i_range</span><span class="p">)</span>      <span class="p">,</span> <span class="p">(</span><span class="n">l_y_offset</span><span class="o">/</span><span class="n">i_range</span><span class="p">)</span>     <span class="p">],</span>
                        <span class="p">[(</span><span class="o">-</span><span class="n">l_y_offset</span><span class="o">/</span><span class="p">(</span><span class="n">i_range</span><span class="o">**</span><span class="mi">2</span><span class="p">)),</span> <span class="p">(</span><span class="n">l_x_offset</span><span class="o">/</span><span class="p">(</span><span class="n">i_range</span><span class="o">**</span><span class="mi">2</span><span class="p">))]])</span>

        <span class="c1"># See theory how H_t is constructed. H_p goes only along the first three columns
</span>        <span class="n">H_t</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">H_p</span>
        <span class="n">H_t</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="p">:</span> <span class="mi">5</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">H_l</span>

        <span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">measure_cov</span>

    <span class="c1"># Now after obtaining H_t and Q_t, find Kalman gain K
</span>    <span class="c1"># K = (3+2k, 3+2k) @ (3+2k, 2k) @ (2k, 2k) = (3+2k, 2k)
</span>    <span class="n">K</span> <span class="o">=</span> <span class="n">P_pre</span> <span class="o">@</span> <span class="n">H_t</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">inv</span><span class="p">((</span><span class="n">H_t</span> <span class="o">@</span> <span class="n">P_pre</span> <span class="o">@</span> <span class="n">H_t</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Q</span><span class="p">)</span>

    <span class="c1"># Update pose(mean) and noise(covariance) using K
</span>    <span class="n">X_updated</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">X_pre</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">X_updated</span> <span class="o">=</span> <span class="n">X_pre</span> <span class="o">+</span> <span class="p">(</span><span class="n">K</span> <span class="o">@</span> <span class="p">(</span><span class="n">measure</span> <span class="o">-</span> <span class="n">z_t</span><span class="p">))</span> <span class="c1"># (measure - z_t) = (actual - prediction)
</span>
    <span class="n">P_updated</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">K</span> <span class="o">@</span> <span class="n">H_t</span><span class="p">))</span> <span class="o">@</span> <span class="n">P_pre</span>

    <span class="k">return</span> <span class="n">X_updated</span><span class="p">,</span> <span class="n">P_updated</span>
</code></pre></div></div>
      <h2 id="overview-of-implementation">
        
        
          <a href="#overview-of-implementation" class="anchor-heading" aria-labelledby="overview-of-implementation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Overview of Implementation
        
        
      </h2>
    

<p><img src="/images/SLAM/EKF/imp_1.png" alt="" /></p>

<p><img src="/images/SLAM/EKF/imp_2.png" alt="" /></p>

<p><img src="/images/SLAM/EKF/imp_3.png" alt="" /></p>
      <h3 id="visual-interpretation">
        
        
          <a href="#visual-interpretation" class="anchor-heading" aria-labelledby="visual-interpretation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Visual Interpretation
        
        
      </h3>
    

<p><img src="/images/SLAM/EKF/predict_graph.png" alt="" /></p>

<p><img src="/images/SLAM/EKF/update_graph.png" alt="" /></p>

<p><img src="/images/SLAM/EKF/update_3_graph.png" alt="" /></p>

<p><img src="/images/SLAM/EKF/update_4_graph.png" alt="" /></p>
      <h2 id="detailed-notes-and-derivation">
        
        
          <a href="#detailed-notes-and-derivation" class="anchor-heading" aria-labelledby="detailed-notes-and-derivation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Detailed Notes and Derivation
        
        
      </h2>
    

<p class="btn fs-5 mb-4 mb-md-0"><a href="https://drive.google.com/file/d/1sjxMO7rdThf_R7wtCv-aCYT6wKwvaGkB/view?usp=sharing">Detailed Derivation</a></p>

        

        

        
        
          <hr>
          <footer>
            

            <p class="text-small text-grey-dk-100 mb-0"></p>

            
              <div class="d-flex mt-2">
                
                
              </div>
            
          </footer>
        

      </div>
    </div>

    
      

      <div class="search-overlay"></div>
    
  </div>
</body>
</html>

