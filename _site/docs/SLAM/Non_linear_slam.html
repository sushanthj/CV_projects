

<!DOCTYPE html>

<html lang="en-US">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">

  

  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

  <link rel="stylesheet" href="/assets/css/just-the-docs-default.css">

  

  
    <script type="text/javascript" src="/assets/js/vendor/lunr.min.js"></script>
  
  <script type="text/javascript" src="/assets/js/just-the-docs.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Least Squares SLAM | Navigating Robotics</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Least Squares SLAM" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Projects and assignments during my time in CMU" />
<meta property="og:description" content="Projects and assignments during my time in CMU" />
<link rel="canonical" href="http://localhost:4000/docs/SLAM/Non_linear_slam.html" />
<meta property="og:url" content="http://localhost:4000/docs/SLAM/Non_linear_slam.html" />
<meta property="og:site_name" content="Navigating Robotics" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Least Squares SLAM" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Projects and assignments during my time in CMU","headline":"Least Squares SLAM","url":"http://localhost:4000/docs/SLAM/Non_linear_slam.html"}</script>
<!-- End Jekyll SEO tag -->


  

</head>

<body>
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
    <symbol id="svg-link" viewBox="0 0 24 24">
      <title>Link</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link">
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
      </svg>
    </symbol>
    <symbol id="svg-search" viewBox="0 0 24 24">
      <title>Search</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search">
        <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
    </symbol>
    <symbol id="svg-menu" viewBox="0 0 24 24">
      <title>Menu</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
        <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </symbol>
    <symbol id="svg-arrow-right" viewBox="0 0 24 24">
      <title>Expand</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
    </symbol>
    <symbol id="svg-doc" viewBox="0 0 24 24">
      <title>Document</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file">
        <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>
      </svg>
    </symbol>
  </svg>

  <div class="side-bar">
    <div class="site-header">
      <a href="http://localhost:4000/" class="site-title lh-tight">
  Navigating Robotics

</a>
      <a href="#" id="menu-button" class="site-button">
        <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg>
      </a>
    </div>
    <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav">
      
        <ul class="nav-list"><li class="nav-list-item"><a href="http://localhost:4000/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="http://localhost:4000/intro/" class="nav-list-link">Building this Page</a></li><li class="nav-list-item"><a href="http://localhost:4000/planar_homography/" class="nav-list-link">Planar Homography</a></li><li class="nav-list-item"><a href="http://localhost:4000/3D_reconstruction/" class="nav-list-link">3D_reconstruction</a></li><li class="nav-list-item"><a href="http://localhost:4000/optical_flow/" class="nav-list-link">Optical Flow and Image Alignment</a></li><li class="nav-list-item"><a href="http://localhost:4000/constr_rrt/" class="nav-list-link">Constrained RRT</a></li><li class="nav-list-item"><a href="http://localhost:4000/spatial_pyramid_matching/" class="nav-list-link">Spatial Pyramid Matching for Scene Classification</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/Deep%20Learning" class="nav-list-link">Deep Learning</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/Basics.html" class="nav-list-link">ML Basics</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/DL.html" class="nav-list-link">Deep Learning Starter</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/IDL1.html" class="nav-list-link">MLPs (IDL1)</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/IDL2.html" class="nav-list-link">Classifiers (IDL2)</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/IDL3.html" class="nav-list-link">Optimizers and Regularizers (IDL3)</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/IDL4.html" class="nav-list-link">Intro to CNNs</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Deep%20Learning/IDL5.html" class="nav-list-link">Lessons Learnt 1</a></li></ul></li><li class="nav-list-item"><a href="http://localhost:4000/pytorch/" class="nav-list-link">Intro to Pytorch</a></li><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/SLAM" class="nav-list-link">SLAM</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Probability_review.html" class="nav-list-link">Recap on Probability</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Expectation_and_cov.html" class="nav-list-link">Expectation and Covariance</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Particle%20Filter_theory.html" class="nav-list-link">Particle Filters Theory</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/EKF.html" class="nav-list-link">EKF</a></li><li class="nav-list-item  active"><a href="http://localhost:4000/docs/SLAM/Non_linear_slam.html" class="nav-list-link active">Least Squares SLAM</a></li></ul></li><li class="nav-list-item"><a href="http://localhost:4000/mrsd_proj/" class="nav-list-link">MRSD Capstone Project</a></li><li class="nav-list-item"><a href="http://localhost:4000/camera_model/" class="nav-list-link">Camera Models</a></li><li class="nav-list-item"><a href="http://localhost:4000/numpy/" class="nav-list-link">Numpy</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/Vision%20with%20C++" class="nav-list-link">Computer Vision using C++</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/Vision%20with%20C++/Eigen.html" class="nav-list-link">Linear Algebra in Eigen</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Vision%20with%20C++/Eigen_applied.html" class="nav-list-link">Eigen, OpenCV, and Images</a></li></ul></li></ul>

      
    </nav>
    <footer class="site-footer">
      This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.
    </footer>
  </div>
  <div class="main" id="top">
    <div id="main-header" class="main-header">
      
        <div class="search">
          <div class="search-input-wrap">
            <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Navigating Robotics" aria-label="Search Navigating Robotics" autocomplete="off">
            <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label>
          </div>
          <div id="search-results" class="search-results"></div>
        </div>
      
      
      
        <nav aria-label="Auxiliary" class="aux-nav">
          <ul class="aux-nav-list">
            
              <li class="aux-nav-list-item">
                <a href="//github.com/sushanthj" class="site-button"
                  
                >
                  Sushanth Jayanth's github
                </a>
              </li>
            
          </ul>
        </nav>
      
    </div>
    <div id="main-content-wrap" class="main-content-wrap">
      
        <nav aria-label="Breadcrumb" class="breadcrumb-nav">
            <ol class="breadcrumb-nav-list">
              
                <li class="breadcrumb-nav-list-item"><a href="http://localhost:4000/docs/SLAM">SLAM</a></li>
              
              <li class="breadcrumb-nav-list-item"><span>Least Squares SLAM</span></li>
            </ol>
          </nav>
        
      
      <div id="main-content" class="main-content" role="main">
        
          <details open="">
  <summary>
    Table of contents
  {: .text-delta }
  </summary>
<ol id="markdown-toc">
  <li><a href="#background" id="markdown-toc-background">Background</a>    <ol>
      <li><a href="#learning-goals" id="markdown-toc-learning-goals">Learning Goals</a></li>
    </ol>
  </li>
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#2d-linear-least-squares-slam" id="markdown-toc-2d-linear-least-squares-slam">2D Linear Least Squares SLAM</a>    <ol>
      <li><a href="#why-least-squares" id="markdown-toc-why-least-squares">Why Least Squares?</a></li>
      <li><a href="#derivation" id="markdown-toc-derivation">Derivation</a>        <ol>
          <li><a href="#intuition-for-our-final-solution" id="markdown-toc-intuition-for-our-final-solution">Intuition for our final solution</a></li>
        </ol>
      </li>
      <li><a href="#measurement-funtion-hx" id="markdown-toc-measurement-funtion-hx">Measurement Funtion h(x)</a>        <ol>
          <li><a href="#odometry-measurement-function" id="markdown-toc-odometry-measurement-function">Odometry Measurement Function</a></li>
          <li><a href="#landmark-measurment-function" id="markdown-toc-landmark-measurment-function">Landmark Measurment Function</a></li>
          <li><a href="#shapes-of-the-a-and-b-matrices" id="markdown-toc-shapes-of-the-a-and-b-matrices">Shapes of the A and b matrices</a></li>
        </ol>
      </li>
      <li><a href="#2d-linear-least-squares-in-code" id="markdown-toc-2d-linear-least-squares-in-code">2D Linear Least Squares in Code</a>        <ol>
          <li><a href="#fully-define-the-a-and-b-matrices-setup-step" id="markdown-toc-fully-define-the-a-and-b-matrices-setup-step">Fully Define the A and b matrices (setup step)</a></li>
          <li><a href="#solving-the-linear-system" id="markdown-toc-solving-the-linear-system">Solving the Linear System</a></li>
        </ol>
      </li>
      <li><a href="#naieve-solvers" id="markdown-toc-naieve-solvers">Naieve Solvers</a>        <ol>
          <li><a href="#pseudo-inverse" id="markdown-toc-pseudo-inverse">Pseudo-Inverse</a>            <ol>
              <li><a href="#why-not-do-svd" id="markdown-toc-why-not-do-svd">Why not do SVD?</a></li>
              <li><a href="#scipy-default-solver" id="markdown-toc-scipy-default-solver">Scipy Default Solver</a></li>
            </ol>
          </li>
        </ol>
      </li>
      <li><a href="#matrix-factorization---utilizing-the-sparsity" id="markdown-toc-matrix-factorization---utilizing-the-sparsity">Matrix Factorization - Utilizing the Sparsity</a>        <ol>
          <li><a href="#cholesky---lu-decomposition---fast-little-lower-numerical-stability" id="markdown-toc-cholesky---lu-decomposition---fast-little-lower-numerical-stability">Cholesky - LU Decomposition - Fast, little lower numerical stability</a>            <ol>
              <li><a href="#column-ordering" id="markdown-toc-column-ordering">Column Ordering</a></li>
              <li><a href="#chatgpt-explanation" id="markdown-toc-chatgpt-explanation">ChatGPT explanation</a></li>
              <li><a href="#my-understading" id="markdown-toc-my-understading">My Understading</a></li>
            </ol>
          </li>
          <li><a href="#qr-factorization---slower-but-more-stable" id="markdown-toc-qr-factorization---slower-but-more-stable">QR Factorization - Slower, but more stable</a></li>
        </ol>
      </li>
      <li><a href="#results-of-least-sq-optimization-and-visual-inference" id="markdown-toc-results-of-least-sq-optimization-and-visual-inference">Results of Least Sq. Optimization and Visual Inference</a>        <ol>
          <li><a href="#ground-truth-trajectory" id="markdown-toc-ground-truth-trajectory">Ground Truth Trajectory</a></li>
          <li><a href="#optimization-results" id="markdown-toc-optimization-results">Optimization Results</a></li>
          <li><a href="#inference-on-the-runtime-comparisons" id="markdown-toc-inference-on-the-runtime-comparisons">Inference on the Runtime Comparisons</a></li>
          <li><a href="#additionaly-optimization-results" id="markdown-toc-additionaly-optimization-results">Additionaly Optimization Results</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#2d-non-linear-least-squares-slam4" id="markdown-toc-2d-non-linear-least-squares-slam4">2D Non-Linear Least Squares SLAM4</a>    <ol>
      <li><a href="#measurement-functions" id="markdown-toc-measurement-functions">Measurement Functions</a></li>
      <li><a href="#building-the-linear-system-from-non-linear-system" id="markdown-toc-building-the-linear-system-from-non-linear-system">Building the Linear System from Non-Linear System</a></li>
      <li><a href="#non-linear-system-in-code" id="markdown-toc-non-linear-system-in-code">Non Linear System in Code</a></li>
      <li><a href="#results" id="markdown-toc-results">Results</a></li>
      <li><a href="#distinction-between-non-linear-and-linear-optimization" id="markdown-toc-distinction-between-non-linear-and-linear-optimization">Distinction between Non-Linear and Linear Optimization</a></li>
    </ol>
  </li>
</ol>

</details>

<p class="btn fs-5 mb-4 mb-md-0"><a href="https://github.com/sushanthj/SLAM-and-Robot-Autonomy/blob/main/SLAM/Non_linear_Least_Squares/sushantj_hw3.pdf">Detailed write-up</a></p>
      <h1 id="background">
        
        
          <a href="#background" class="anchor-heading" aria-labelledby="background"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Background
        
        
      </h1>
    

<p>In <a href="/docs/SLAM/EKF">EKF</a> we used the jacobian of the measurement model in the update step.</p>

<p><img src="/images/SLAM/EKF/H_t.png" alt="" /></p>

<p><img src="/images/SLAM/EKF/jac_H.png" alt="" /></p>

<p>However, upon deeper inspection we see that this matrix is very sparse <em>(spare = lots of zeros)</em></p>

<p><img src="/images/SLAM/pose_graph/sparsity_explained.png" alt="" /></p>

<ul>
  <li>It would therefore be most efficient if we could utilize this sparsity.</li>
  <li>Additionally, EKF was sort of a local solver in that all prior states were
marginalized out. Hence, we could not improve our estimates of our previous
robot states even if we got more and more measurements.</li>
</ul>
      <h2 id="learning-goals">
        
        
          <a href="#learning-goals" class="anchor-heading" aria-labelledby="learning-goals"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Learning Goals
        
        
      </h2>
    

<ol>
  <li>Learn to optimize operations by exploiting sparsity</li>
  <li>Do Full SLAM using the Least Squares Formulation
(EKF was only online SLAM where prior states were marginalized out)</li>
</ol>
      <h1 id="introduction">
        
        
          <a href="#introduction" class="anchor-heading" aria-labelledby="introduction"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Introduction
        
        
      </h1>
    

<p>Similar to the <a href="/docs/SLAM/EKF">EKF</a> problem, we setup our state vector to comprise both
landmark and robot states. However, here we will make use the <strong>Factor Graph formulation</strong>
which consists of the following components:</p>

<ul>
  <li>Factors (edges)
    <ul>
      <li>Odometry measurements</li>
      <li>Landmark measurements</li>
    </ul>
  </li>
  <li>States (nodes)
    <ul>
      <li>Robot poses</li>
      <li>Landmark poses</li>
    </ul>
  </li>
</ul>

<p><img src="/images/SLAM/pose_graph/factor_graph.png" alt="" /></p>

<p>Here we’re already given the data of the all the factors and states present in the factor graph.
We will use this data to <strong>minimize the variance in the predicted values of each measurement</strong> (odometry measurements or
landmark measurements) between every two connected states on the factor graph.</p>

<p>This minimization will be crafted in a least squares minimization form. The high level procedure to do so
is shown below</p>

<p><img src="/images/SLAM/pose_graph/least_squares_intuition.png" alt="" /></p>

<p>Finally, the factor graph and least squares equivalence is seen below:</p>

<p><img src="/images/SLAM/pose_graph/equivalence.png" alt="" /></p>

<p class="btn fs-5 mb-4 mb-md-0"><a href="https://drive.google.com/file/d/1YWcwMcVkOkE_xX38voyYF7nRC8N2zeMe/view?usp=sharing">Detailed Derivation Linear Least Sq.</a></p>

<p class="btn fs-5 mb-4 mb-md-0"><a href="https://drive.google.com/file/d/1eJBy3T47wljiHbb_UeRwEOhBfJVlkbxQ/view?usp=sharing">Detailed Derivation Non-Linear Least Sq.</a></p>

<p><strong>We will be starting with 2D Linear SLAM and then moving onto 2D Non-Linear SLAM</strong></p>
      <h1 id="2d-linear-least-squares-slam">
        
        
          <a href="#2d-linear-least-squares-slam" class="anchor-heading" aria-labelledby="2d-linear-least-squares-slam"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2D Linear Least Squares SLAM
        
        
      </h1>
    

<p>Here we will look to best fit our measurements <strong>(z)</strong> to our observed robot states <strong>(θ)</strong>.
Specifically, we will try to optimize over both the robot states and sensor measurements 
and try to reach the best middle ground. <strong>Factor Graphs or Pose Graphs give us the 
best method of doing such global optimizations</strong>.</p>

<p>This global optimization is first defined in the below manner in
terms of increasing probability  <strong>p(z | θ)</strong></p>

<p><img src="/images/SLAM/pose_graph/maximization.png" alt="" /></p>
      <h4 id="why-least-squares">
        
        
          <a href="#why-least-squares" class="anchor-heading" aria-labelledby="why-least-squares"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Why Least Squares?
        
        
      </h4>
    

<p>The reason we will formulate the above maximization equations as a least squares problem is
becuase we get mulitple landmark measurements as our robot moves, ending up with more
observations than variables (states in state vector). <strong>Hence its not possible to extract an
exact solution which fits mathematically.</strong> Therefore, our next easiest guess would be a least
squares formulation.</p>

<p>Think of it like simultaneous equations, if we have 3 variables, we need only 3 equations
to solve for the variables. However, if we have 4 equations, it’s overdetermined. Similaraly,
here we have only few robot states, but a lot of observations constraining those states. These
observations can be odometry readings or sensor readings.</p>
      <h2 id="derivation">
        
        
          <a href="#derivation" class="anchor-heading" aria-labelledby="derivation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Derivation
        
        
      </h2>
    

<p>The exact derivation can be seen <a href="https://drive.google.com/file/d/1YWcwMcVkOkE_xX38voyYF7nRC8N2zeMe/view?usp=sharing">in this link</a>. The abbreviated version is shown below.</p>

<p>Now, let’s assume that our measurement function <strong>h(x)</strong> is linear
<span style="color:pink"> (Even if it isn’t linear, we approximate the
non-linear function by taking the first order taylor expansion later on) </span></p>

<p><img src="/images/SLAM/pose_graph/derivation_0.png" alt="" /></p>

<p><img src="/images/SLAM/pose_graph/derivation_1.png" alt="" /></p>

<p><img src="/images/SLAM/pose_graph/derivation_2.png" alt="" /></p>

<p>Here we don’t solve directly for <strong>Ax = b</strong> because of noise in the measurements. Instead,
we do the following:</p>

<p><img src="/images/SLAM/pose_graph/derivation_filler_1.png" alt="" /></p>

<p>The above equation will lead to: <img src="/images/SLAM/pose_graph/derivation_3.png" alt="" /></p>

<p><img src="/images/SLAM/pose_graph/derivation_4.png" alt="" /></p>

<p><img src="/images/SLAM/pose_graph/derivation_5.png" alt="" /></p>
      <h3 id="intuition-for-our-final-solution">
        
        
          <a href="#intuition-for-our-final-solution" class="anchor-heading" aria-labelledby="intuition-for-our-final-solution"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Intuition for our final solution
        
        
      </h3>
    

<p><img src="/images/SLAM/pose_graph/solution_intuition.png" alt="" /></p>
      <h2 id="measurement-funtion-hx">
        
        
          <a href="#measurement-funtion-hx" class="anchor-heading" aria-labelledby="measurement-funtion-hx"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Measurement Funtion h(x)
        
        
      </h2>
    

<!-- Here we look to minimizing the uncertainty in our measurements (which are the edges of
our factor graph). To do so, we need to define measurement functions for these measurements. -->
      <h3 id="odometry-measurement-function">
        
        
          <a href="#odometry-measurement-function" class="anchor-heading" aria-labelledby="odometry-measurement-function"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Odometry Measurement Function
        
        
      </h3>
    

<p><img src="/images/SLAM/pose_graph/odom_meas.png" alt="" /></p>
      <h3 id="landmark-measurment-function">
        
        
          <a href="#landmark-measurment-function" class="anchor-heading" aria-labelledby="landmark-measurment-function"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Landmark Measurment Function
        
        
      </h3>
    

<p><img src="/images/SLAM/pose_graph/land_meas.png" alt="" /></p>
      <h3 id="shapes-of-the-a-and-b-matrices">
        
        
          <a href="#shapes-of-the-a-and-b-matrices" class="anchor-heading" aria-labelledby="shapes-of-the-a-and-b-matrices"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Shapes of the A and b matrices
        
        
      </h3>
    

<p>During the derivation we saw that</p>

<ul>
  <li><img src="/images/SLAM/pose_graph/A_math.png" alt="" /></li>
  <li><img src="/images/SLAM/pose_graph/b_math.png" alt="" /></li>
</ul>

<ol>
  <li>Now, the <strong>A</strong> matrix is seen to be the same size as the jacobian. We define the jacobian
below (it’s equated to A, but it’s yet to be scaled by Σ^-0.5)</li>
  <li><strong>b</strong> is the same size as the number of measurements <strong>z</strong>. Hence, h_0 should also be a
vector or the same size</li>
</ol>

<p><img src="/images/SLAM/pose_graph/A_b_shapes.png" alt="" /></p>

<ul>
  <li>We see that the rows of the jacobian are p, u1, u2, d1, d2 ..</li>
  <li>Since we’re working in 2D, each of these measurements will have an <em>x</em> and <em>y</em> component</li>
  <li>p is technically not a measurement, but is the starting pose of the robot</li>
  <li>
    <p>Hence we can define the number of rows of <strong>A to be equal to (n_odom + 1) * 2 + n_obs * 2</strong></p>
  </li>
  <li>We also see that the <strong>b</strong> vector has no. of rows = no. of measurements</li>
  <li>Therefore size of <strong>b = n_poses * 2 + n_landmarks * 2</strong></li>
</ul>
      <h2 id="2d-linear-least-squares-in-code">
        
        
          <a href="#2d-linear-least-squares-in-code" class="anchor-heading" aria-labelledby="2d-linear-least-squares-in-code"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2D Linear Least Squares in Code
        
        
      </h2>
    
      <h3 id="fully-define-the-a-and-b-matrices-setup-step">
        
        
          <a href="#fully-define-the-a-and-b-matrices-setup-step" class="anchor-heading" aria-labelledby="fully-define-the-a-and-b-matrices-setup-step"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Fully Define the A and b matrices (setup step)
        
        
      </h3>
    

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create_linear_system</span><span class="p">(</span><span class="n">odoms</span><span class="p">,</span> <span class="n">observations</span><span class="p">,</span> <span class="n">sigma_odom</span><span class="p">,</span> <span class="n">sigma_observation</span><span class="p">,</span>
                         <span class="n">n_poses</span><span class="p">,</span> <span class="n">n_landmarks</span><span class="p">):</span>
    <span class="s">'''
    \param odoms Odometry measurements between i and i+1 in the global coordinate system. Shape: (n_odom, 2).
    \param observations Landmark measurements between pose i and landmark j in the global coordinate system. Shape: (n_obs, 4).
    \param sigma_odom Shared covariance matrix of odometry measurements. Shape: (2, 2).
    \param sigma_observation Shared covariance matrix of landmark measurements. Shape: (2, 2).

    </span><span class="se">\r</span><span class="s">eturn A (M, N) Jacobian matrix.
    </span><span class="se">\r</span><span class="s">eturn b (M, ) Residual vector.
    where M = (n_odom + 1) * 2 + n_obs * 2, total rows of measurements.
          N = n_poses * 2 + n_landmarks * 2, length of the state vector.
    '''</span>

    <span class="n">n_odom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">odoms</span><span class="p">)</span>
    <span class="n">n_obs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">observations</span><span class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_odom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">n_obs</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">n_poses</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">n_landmarks</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="p">))</span>

    <span class="c1"># Prepare Sigma^{-1/2}.
</span>    <span class="n">sqrt_inv_odom</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">inv</span><span class="p">(</span><span class="n">scipy</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">sqrtm</span><span class="p">(</span><span class="n">sigma_odom</span><span class="p">))</span>
    <span class="n">sqrt_inv_obs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">inv</span><span class="p">(</span><span class="n">scipy</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">sqrtm</span><span class="p">(</span><span class="n">sigma_observation</span><span class="p">))</span>

    <span class="c1"># TODO: First fill in the prior to anchor the 1st pose at (0, 0)
</span>    <span class="c1"># The prior is just a reference frame, it also has some uncertainty, but no measurement
</span>    <span class="c1"># Hence the measurement function which estimates the prior is just a identity function
</span>    <span class="c1"># i.e h_p(r_t) = r_t. Since no measurements exist, the b matrix will have only zeros (already the case)
</span>
    <span class="c1"># Here we also define the uncertainty in prior is same as odom uncertainty
</span>    <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt_inv_odom</span> <span class="o">@</span> <span class="n">np</span><span class="p">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># no need to update b (already zeros)
</span>
    <span class="c1"># TODO: Then fill in odometry measurements
</span>    <span class="s">"""
    The A matrix structure is shown in the theory section. Along the rows, it has:
        - predicted prior (of size 1)
        - predicted odom measurements (of size n_odom)
        - predicted landmark measurements (of size n_obs)

    We will also follow the same order
    """</span>

    <span class="n">H_odom</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">H_land</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">A_fill_odom</span> <span class="o">=</span> <span class="n">sqrt_inv_odom</span> <span class="o">@</span> <span class="n">H_odom</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_odom</span><span class="p">):</span>
        <span class="c1"># declare an offset for i to include the prior term (which only occurs once along rows)
</span>        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>

        <span class="c1"># A[2*j : 2*j+2 , 2*j : 2*j+4] = sqrt_inv_odom @ H_odom
</span>        <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_fill_odom</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt_inv_odom</span> <span class="o">@</span> <span class="n">odoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># TODO: Then fill in landmark measurements
</span>    <span class="n">A_fill_land</span> <span class="o">=</span> <span class="n">sqrt_inv_obs</span> <span class="o">@</span> <span class="n">H_land</span> <span class="c1"># H_land like H_odom is also a 2x4 matrix
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_obs</span><span class="p">):</span>
        <span class="c1"># observations = (52566,4) # (pose_index, landmark_index, measurement_x, measurement_y)
</span>        <span class="c1"># Therefore we need to check which pose is associated with which landmark
</span>        <span class="n">p_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">observations</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">l_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">observations</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># offset to account for prior (offset only along rows) + all odom measurements above
</span>        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n_odom</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">p_idx</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">p_idx</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_fill_land</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n_poses</span> <span class="o">+</span> <span class="n">l_idx</span><span class="p">):</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n_poses</span> <span class="o">+</span> <span class="n">l_idx</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_fill_land</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt_inv_obs</span> <span class="o">@</span> <span class="n">observations</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

    <span class="c1"># Convert matrix to sparse format which scipy can use
</span>    <span class="k">return</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">b</span>
</code></pre></div></div>
      <h3 id="solving-the-linear-system">
        
        
          <a href="#solving-the-linear-system" class="anchor-heading" aria-labelledby="solving-the-linear-system"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Solving the Linear System
        
        
      </h3>
    

<p>The previous function has access to all the odometry and landmark measurements at once.
Therefore <strong>we already have fleshed out the A and b matrices</strong>. Using this, we can then
solve for the same as shown below:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>

    <span class="n">n_poses</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gt_traj</span><span class="p">)</span>
    <span class="n">n_landmarks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gt_landmarks</span><span class="p">)</span>

    <span class="n">odoms</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'odom'</span><span class="p">]</span>
    <span class="n">observations</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'observations'</span><span class="p">]</span>
    <span class="n">sigma_odom</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'sigma_odom'</span><span class="p">]</span>
    <span class="n">sigma_landmark</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'sigma_landmark'</span><span class="p">]</span>
    <span class="s">"""
    The shapes of above values for 2d_linear.npz are:
    odoms = (999,2) which makes sense since there are 1000 robot poses
    observations = (52566,4) # (pose_index, landmark_index, measurement_x, measurement_y)
    sigma_odom = (2,2)
    sigma_landmark = (2,2)
    """</span>

    <span class="c1"># Build a linear system
</span>    <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">create_linear_system</span><span class="p">(</span><span class="n">odoms</span><span class="p">,</span> <span class="n">observations</span><span class="p">,</span> <span class="n">sigma_odom</span><span class="p">,</span>
                                <span class="n">sigma_landmark</span><span class="p">,</span> <span class="n">n_poses</span><span class="p">,</span> <span class="n">n_landmarks</span><span class="p">)</span>

    <span class="c1"># Solve with the selected method
</span>    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">args</span><span class="p">.</span><span class="n">method</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Applying </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

        <span class="n">total_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total_iters</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">repeats</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_iters</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">total_time</span> <span class="o">+=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s"> takes </span><span class="si">{</span><span class="n">total_time</span> <span class="o">/</span> <span class="n">total_iters</span><span class="si">}</span><span class="s">s on average'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="p">.</span><span class="n">spy</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
            <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">traj</span><span class="p">,</span> <span class="n">landmarks</span> <span class="o">=</span> <span class="n">devectorize_state</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_poses</span><span class="p">)</span>

        <span class="c1"># Visualize the final result
</span>        <span class="n">plot_traj_and_landmarks</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">landmarks</span><span class="p">,</span> <span class="n">gt_traj</span><span class="p">,</span> <span class="n">gt_landmarks</span><span class="p">)</span>
</code></pre></div></div>

<p>As seen above, we have have multiple <em>methods</em> to solve the minimization function. Lookup
scipy.optimize.minimize to see a simple way in which one can solve an optimization problem
by defining an objective function. Here, our objective function is the <strong>Ax = b</strong></p>

<p>The methods we will define below are pre-programmed to solve for such linear equations.</p>
      <h2 id="naieve-solvers">
        
        
          <a href="#naieve-solvers" class="anchor-heading" aria-labelledby="naieve-solvers"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Naieve Solvers
        
        
      </h2>
    
      <h3 id="pseudo-inverse">
        
        
          <a href="#pseudo-inverse" class="anchor-heading" aria-labelledby="pseudo-inverse"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Pseudo-Inverse
        
        
      </h3>
    

<p>During our derivation we saw that one simple way to solve our minimization problem
is to use the psuedo-inverse:</p>

<p><img src="/images/SLAM/pose_graph/pseudo_inv.png" alt="" /></p>

<p>This is done in code as shown below:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve_pinv</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="c1"># TODO: return x s.t. Ax = b using pseudo inverse.
</span>    <span class="n">N</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="p">))</span>
    <span class="c1"># Ax = b  &lt;======&gt; inv(A.T @ A) @ A.T @ A @ x = A.T b
</span>    <span class="n">x</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">A</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="bp">None</span>
</code></pre></div></div>
      <h4 id="why-not-do-svd">
        
        
          <a href="#why-not-do-svd" class="anchor-heading" aria-labelledby="why-not-do-svd"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Why not do SVD?
        
        
      </h4>
    

<p>RECAP</p>
<ul>
  <li>In CV ( see <a href="/Planar%20Homography">Planar Homography</a> ) we saw that our final equation to
solve boiled down to the an Ax = 0 form.</li>
  <li>Here x is found by taking the SVD of A and choosing the eigen vector
(with least eigen value) which forms the <strong>null space of A</strong>.</li>
  <li>Remember, null-space of a vector is the transformation (i.e. transformation matrix) which
squeezed the vector onto a point (i.e. it reduces dimensions to zero).</li>
  <li>In this case <strong>x</strong> is the vector and we find the corresponding transformation matrix which
forms it’s null-space. This matrix then becomes our homography matrix</li>
  <li>
    <p>For a better understanding of SVD, refer to <a href="https://drive.google.com/file/d/1d6xcBbI2qcyaCx-rccI3sc9pdjQFMp2n/view?usp=sharing">This Document</a></p>
  </li>
  <li>In the SLAM problem, we <strong>can’t do SVD mainly because it would take too long to compute!</strong></li>
  <li>The vector here will have a million dimensions</li>
  <li>Also, we won’t be utilizing the sparsity and letting go of an easy improvement</li>
</ul>
      <h4 id="scipy-default-solver">
        
        
          <a href="#scipy-default-solver" class="anchor-heading" aria-labelledby="scipy-default-solver"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Scipy Default Solver
        
        
      </h4>
    

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve_default</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spsolve</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="bp">None</span>
</code></pre></div></div>
      <h2 id="matrix-factorization---utilizing-the-sparsity">
        
        
          <a href="#matrix-factorization---utilizing-the-sparsity" class="anchor-heading" aria-labelledby="matrix-factorization---utilizing-the-sparsity"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Matrix Factorization - Utilizing the Sparsity
        
        
      </h2>
    
      <h3 id="cholesky---lu-decomposition---fast-little-lower-numerical-stability">
        
        
          <a href="#cholesky---lu-decomposition---fast-little-lower-numerical-stability" class="anchor-heading" aria-labelledby="cholesky---lu-decomposition---fast-little-lower-numerical-stability"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Cholesky - LU Decomposition - Fast, little lower numerical stability
        
        
      </h3>
    

<p><img src="/images/SLAM/pose_graph/lu_1.png" alt="" />
<img src="/images/SLAM/pose_graph/lu_2.png" alt="" />
<img src="/images/SLAM/pose_graph/lu_3.png" alt="" />
<img src="/images/SLAM/pose_graph/lu_4.png" alt="" />
<img src="/images/SLAM/pose_graph/lu_5.png" alt="" />
<img src="/images/SLAM/pose_graph/lu_6.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csc_matrix</span><span class="p">,</span> <span class="n">eye</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">inv</span><span class="p">,</span> <span class="n">splu</span><span class="p">,</span> <span class="n">spsolve</span><span class="p">,</span> <span class="n">spsolve_triangular</span>

<span class="k">def</span> <span class="nf">solve_lu</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="c1"># TODO: return x, U s.t. Ax = b, and A = LU with LU decomposition.
</span>    <span class="c1"># https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.splu.html
</span>    <span class="c1"># Better ref: https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.SuperLU.html
</span>    <span class="n">N</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="p">))</span>

    <span class="n">lu</span> <span class="o">=</span> <span class="n">splu</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">A</span><span class="p">,</span> <span class="n">permc_spec</span><span class="o">=</span><span class="s">'NATURAL'</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">lu</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">U</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">lu</span><span class="p">.</span><span class="n">U</span><span class="p">.</span><span class="n">A</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span>


<span class="k">def</span> <span class="nf">solve_lu_colamd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="c1"># TODO: return x, U s.t. Ax = b, and Permutation_rows A Permutration_cols = LU with reordered LU decomposition.
</span>    <span class="c1"># https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.splu.html
</span>    <span class="n">N</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="p">))</span>

    <span class="n">lu</span> <span class="o">=</span> <span class="n">splu</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">A</span><span class="p">,</span> <span class="n">permc_spec</span><span class="o">=</span><span class="s">'COLAMD'</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">lu</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">U</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">lu</span><span class="p">.</span><span class="n">U</span><span class="p">.</span><span class="n">A</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">U</span>
</code></pre></div></div>

<p>Above we see an <em>lu_colamd</em> method defined separately:</p>
      <h4 id="column-ordering">
        
        
          <a href="#column-ordering" class="anchor-heading" aria-labelledby="column-ordering"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Column Ordering
        
        
      </h4>
    
      <h4 id="chatgpt-explanation">
        
        
          <a href="#chatgpt-explanation" class="anchor-heading" aria-labelledby="chatgpt-explanation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> ChatGPT explanation
        
        
      </h4>
    
<p>Sparse LU factorization is a technique used to solve systems of linear equations involving sparse matrices. The process involves decomposing the original matrix into a lower triangular matrix (L), an upper triangular matrix (U), and a permutation matrix (P) such that A = PLU. The resulting LU factorization can then be used to efficiently solve multiple linear systems with the same coefficient matrix.</p>

<p>The choice of column ordering can significantly affect the performance of the LU factorization algorithm. The COLAMD algorithm is an approximate minimum degree ordering method that aims to minimize the fill-in, which refers to the number of additional non-zero entries introduced during the LU factorization process. By reducing the fill-in, the COLAMD ordering can lead to faster factorization and improved computational efficiency.</p>
      <h4 id="my-understading">
        
        
          <a href="#my-understading" class="anchor-heading" aria-labelledby="my-understading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> My Understading
        
        
      </h4>
    
<p>The colamd method rearranges (permutes) the A matrix to avoid accumulation of data in the last few
columns of one of the triangular matrices. This rearragement as seen in helps in the following manner:</p>

<ul>
  <li>The algorithm reorders the columns of the matrix so that the non-zero entries are clustered together</li>
  <li>This can reduce the number of fill-in elements created during the factorization process.</li>
  <li>Therefore reordering can significantly reduce the computational and memory requirements of the LU
decomposition.</li>
</ul>

<p><img src="/images/SLAM/pose_graph/fill_in.png" alt="" /></p>

<p>Some graphical examples which were computed for this dataset is shown below:</p>

<p><img src="/images/SLAM/pose_graph/lu_sparse.png" alt="" /></p>

<p><img src="/images/SLAM/pose_graph/lu_colamd_sparse.png" alt="" /></p>
      <h3 id="qr-factorization---slower-but-more-stable">
        
        
          <a href="#qr-factorization---slower-but-more-stable" class="anchor-heading" aria-labelledby="qr-factorization---slower-but-more-stable"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> QR Factorization - Slower, but more stable
        
        
      </h3>
    

<p><img src="/images/SLAM/pose_graph/qr_1.png" alt="" />
<img src="/images/SLAM/pose_graph/qr_2.png" alt="" />
<img src="/images/SLAM/pose_graph/qr_3.png" alt="" />
<img src="/images/SLAM/pose_graph/qr_4.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve_qr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="c1"># TODO: return x, R s.t. Ax = b, and |Ax - b|^2 = |Rx - d|^2 + |e|^2
</span>    <span class="c1"># https://github.com/theNded/PySPQR
</span>    <span class="n">N</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># rz gives the upper triangular part
</span>    <span class="n">Z</span><span class="p">,</span> <span class="n">R</span> <span class="p">,</span><span class="n">E</span><span class="p">,</span> <span class="n">rank</span> <span class="o">=</span> <span class="n">rz</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">permc_spec</span><span class="o">=</span><span class="s">'NATURAL'</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">spsolve_triangular</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">lower</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span>


<span class="k">def</span> <span class="nf">solve_qr_colamd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="c1"># TODO: return x, R s.t. Ax = b, and |Ax - b|^2 = |R E^T x - d|^2 + |e|^2, with reordered QR decomposition (E is the permutation matrix).
</span>    <span class="c1"># https://github.com/theNded/PySPQR
</span>    <span class="n">N</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># rz gives the upper triangular part
</span>    <span class="n">Z</span><span class="p">,</span> <span class="n">R</span> <span class="p">,</span><span class="n">E</span><span class="p">,</span> <span class="n">rank</span> <span class="o">=</span> <span class="n">rz</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">permc_spec</span><span class="o">=</span><span class="s">'COLAMD'</span><span class="p">)</span>

    <span class="c1"># E is symmetric and is the permutation vector s.t. QR = AE
</span>    <span class="n">E</span> <span class="o">=</span> <span class="n">permutation_vector_to_matrix</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">spsolve_triangular</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="n">lower</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">E</span> <span class="o">@</span> <span class="n">x</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span>
</code></pre></div></div>
      <h2 id="results-of-least-sq-optimization-and-visual-inference">
        
        
          <a href="#results-of-least-sq-optimization-and-visual-inference" class="anchor-heading" aria-labelledby="results-of-least-sq-optimization-and-visual-inference"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Results of Least Sq. Optimization and Visual Inference
        
        
      </h2>
    
      <h3 id="ground-truth-trajectory">
        
        
          <a href="#ground-truth-trajectory" class="anchor-heading" aria-labelledby="ground-truth-trajectory"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ground Truth Trajectory
        
        
      </h3>
    
<p><img src="/images/SLAM/pose_graph/ground_truth.png" alt="" /></p>
      <h3 id="optimization-results">
        
        
          <a href="#optimization-results" class="anchor-heading" aria-labelledby="optimization-results"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Optimization Results
        
        
      </h3>
    

<p><img src="/images/SLAM/pose_graph/pinv_linear.png" alt="" /></p>

<p><img src="/images/SLAM/pose_graph/lu_colamd_linear.png" alt="" /></p>

<p><img src="/images/SLAM/pose_graph/linear_runtime_comp.png" alt="" /></p>
      <h3 id="inference-on-the-runtime-comparisons">
        
        
          <a href="#inference-on-the-runtime-comparisons" class="anchor-heading" aria-labelledby="inference-on-the-runtime-comparisons"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Inference on the Runtime Comparisons
        
        
      </h3>
    

<p><img src="/images/SLAM/pose_graph/linear_inference_1.png" alt="" /></p>

<p><img src="/images/SLAM/pose_graph/linear_inference_2.png" alt="" /></p>

<p>Therefore, it’s safe to say that the <strong>when A matrix is more dense, the colamd method makes
sense and efficiency boost is observed</strong>. Therefore, for small A matrices, it might not be
necessary.</p>

<p><img src="/images/SLAM/pose_graph/sparse_real_ex.png" alt="" /></p>
      <h3 id="additionaly-optimization-results">
        
        
          <a href="#additionaly-optimization-results" class="anchor-heading" aria-labelledby="additionaly-optimization-results"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Additionaly Optimization Results
        
        
      </h3>
    

<p><img src="/images/SLAM/pose_graph/linear_gt2.png" alt="" /></p>

<p><img src="/images/SLAM/pose_graph/linear_qr2.png" alt="" /></p>
      <h1 id="2d-non-linear-least-squares-slam4">
        
        
          <a href="#2d-non-linear-least-squares-slam4" class="anchor-heading" aria-labelledby="2d-non-linear-least-squares-slam4"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 2D Non-Linear Least Squares SLAM4
        
        
      </h1>
    
      <h2 id="measurement-functions">
        
        
          <a href="#measurement-functions" class="anchor-heading" aria-labelledby="measurement-functions"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Measurement Functions
        
        
      </h2>
    

<p><img src="/images/SLAM/pose_graph/non_linear_meas_func1.png" alt="" />
<img src="/images/SLAM/pose_graph/non_linear_meas_func2.png" alt="" /></p>
      <h2 id="building-the-linear-system-from-non-linear-system">
        
        
          <a href="#building-the-linear-system-from-non-linear-system" class="anchor-heading" aria-labelledby="building-the-linear-system-from-non-linear-system"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Building the Linear System from Non-Linear System
        
        
      </h2>
    

<p><img src="/images/SLAM/pose_graph/non_linear_system.png" alt="" /></p>
      <h2 id="non-linear-system-in-code">
        
        
          <a href="#non-linear-system-in-code" class="anchor-heading" aria-labelledby="non-linear-system-in-code"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Non Linear System in Code
        
        
      </h2>
    

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">warp2pi</span><span class="p">(</span><span class="n">angle_rad</span><span class="p">):</span>
    <span class="s">"""
    Warps an angle in [-pi, pi]. Used in the update step.
    \param angle_rad Input angle in radius
    </span><span class="se">\r</span><span class="s">eturn angle_rad_warped Warped angle to [-\pi, \pi].
    """</span>
    <span class="n">angle_rad</span> <span class="o">=</span> <span class="n">angle_rad</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span>
        <span class="p">(</span><span class="n">angle_rad</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">angle_rad</span>


<span class="k">def</span> <span class="nf">init_states</span><span class="p">(</span><span class="n">odoms</span><span class="p">,</span> <span class="n">observations</span><span class="p">,</span> <span class="n">n_poses</span><span class="p">,</span> <span class="n">n_landmarks</span><span class="p">):</span>
    <span class="s">'''
    Initialize the state vector given odometry and observations.
    '''</span>
    <span class="n">traj</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_poses</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">landmarks</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_landmarks</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">landmarks_mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_landmarks</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">odoms</span><span class="p">)):</span>
        <span class="n">traj</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">odoms</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">observations</span><span class="p">)):</span>
        <span class="n">pose_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">observations</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">landmark_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">observations</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">landmarks_mask</span><span class="p">[</span><span class="n">landmark_idx</span><span class="p">]:</span>
            <span class="n">landmarks_mask</span><span class="p">[</span><span class="n">landmark_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="n">pose</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="n">pose_idx</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">theta</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">observations</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span>

            <span class="n">landmarks</span><span class="p">[</span><span class="n">landmark_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pose</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">landmarks</span><span class="p">[</span><span class="n">landmark_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pose</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">traj</span><span class="p">,</span> <span class="n">landmarks</span>


<span class="k">def</span> <span class="nf">odometry_estimation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="s">'''
    \param x State vector containing both the pose and landmarks
    \param i Index of the pose to start from (odometry between pose i and i+1)
    </span><span class="se">\r</span><span class="s">eturn odom Odometry (\Delta x, \Delta y) in the shape (2, )
    '''</span>
    <span class="c1"># TODO: return odometry estimation
</span>    <span class="n">odom</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="p">))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">odom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span>
        <span class="n">odom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">ipdb</span><span class="p">.</span><span class="n">set_trace</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">odom</span>


<span class="k">def</span> <span class="nf">bearing_range_estimation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n_poses</span><span class="p">):</span>
    <span class="s">'''
    \param x State vector containing both the pose and landmarks
    \param i Index of the pose to start from
    \param j Index of the landmark to be measured
    \param n_poses Number of poses
    </span><span class="se">\r</span><span class="s">eturn obs Observation from pose i to landmark j (theta, d) in the shape (2, )
    '''</span>
    <span class="c1"># TODO: return bearing range estimations
</span>    <span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="p">))</span>

    <span class="c1"># given the robot pose and landmark location, get the bearing estimate (see theory)
</span>    <span class="n">y_dist</span> <span class="o">=</span> <span class="n">x</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">n_poses</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x_dist</span> <span class="o">=</span> <span class="n">x</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">n_poses</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">)]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">)]</span>
    <span class="n">obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">warp2pi</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y_dist</span><span class="p">,</span> <span class="n">x_dist</span><span class="p">))</span>
    <span class="n">obs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x_dist</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y_dist</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">obs</span>


<span class="k">def</span> <span class="nf">compute_meas_obs_jacobian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n_poses</span><span class="p">):</span>
    <span class="s">'''
    \param x State vector containing both the pose and landmarks
    \param i Index of the pose to start from
    \param j Index of the landmark to be measured
    \param n_poses Number of poses
    </span><span class="se">\r</span><span class="s">eturn jacobian Derived Jacobian matrix in the shape (2, 4)
    '''</span>
    <span class="c1"># TODO: return jacobian matrix
</span>    <span class="n">jacobian</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

    <span class="n">y_dist</span> <span class="o">=</span> <span class="n">x</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">n_poses</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x_dist</span> <span class="o">=</span> <span class="n">x</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">n_poses</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">)]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">)]</span>

    <span class="n">sensor_range</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x_dist</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y_dist</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">jacobian</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_dist</span><span class="o">/</span><span class="p">(</span><span class="n">sensor_range</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">jacobian</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x_dist</span><span class="o">/</span><span class="p">(</span><span class="n">sensor_range</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">jacobian</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">y_dist</span><span class="o">/</span><span class="p">(</span><span class="n">sensor_range</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">jacobian</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_dist</span><span class="o">/</span><span class="p">(</span><span class="n">sensor_range</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">jacobian</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x_dist</span><span class="o">/</span><span class="n">sensor_range</span>
    <span class="n">jacobian</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">y_dist</span><span class="o">/</span><span class="n">sensor_range</span>
    <span class="n">jacobian</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_dist</span><span class="o">/</span><span class="n">sensor_range</span>
    <span class="n">jacobian</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_dist</span><span class="o">/</span><span class="n">sensor_range</span>

    <span class="k">return</span> <span class="n">jacobian</span>


<span class="k">def</span> <span class="nf">create_linear_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">odoms</span><span class="p">,</span> <span class="n">observations</span><span class="p">,</span> <span class="n">sigma_odom</span><span class="p">,</span> <span class="n">sigma_observation</span><span class="p">,</span>
                         <span class="n">n_poses</span><span class="p">,</span> <span class="n">n_landmarks</span><span class="p">):</span>
    <span class="s">'''
    \param x State vector x at which we linearize the system.
    \param odoms Odometry measurements between i and i+1 in the global coordinate system. Shape: (n_odom, 2).
    \param observations Landmark measurements between pose i and landmark j in the global coordinate system. Shape: (n_obs, 4).
    \param sigma_odom Shared covariance matrix of odometry measurements. Shape: (2, 2).
    \param sigma_observation Shared covariance matrix of landmark measurements. Shape: (2, 2).

    </span><span class="se">\r</span><span class="s">eturn A (M, N) Jacobian matrix.
    </span><span class="se">\r</span><span class="s">eturn b (M, ) Residual vector.
    where M = (n_odom + 1) * 2 + n_obs * 2, total rows of measurements.
          N = n_poses * 2 + n_landmarks * 2, length of the state vector.
    '''</span>

    <span class="n">n_odom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">odoms</span><span class="p">)</span>
    <span class="n">n_obs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">observations</span><span class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_odom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">n_obs</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">n_poses</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">n_landmarks</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="p">))</span>

    <span class="n">sqrt_inv_odom</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">inv</span><span class="p">(</span><span class="n">scipy</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">sqrtm</span><span class="p">(</span><span class="n">sigma_odom</span><span class="p">))</span>
    <span class="n">sqrt_inv_obs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">inv</span><span class="p">(</span><span class="n">scipy</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">sqrtm</span><span class="p">(</span><span class="n">sigma_observation</span><span class="p">))</span>

    <span class="c1"># TODO: First fill in the prior to anchor the 1st pose at (0, 0)
</span>    <span class="c1"># The prior is just a reference frame, it also has some uncertainty, but no measurement
</span>    <span class="c1"># Hence the measurement function which estimates the prior is just a identity function
</span>    <span class="c1"># i.e h_p(r_t) = r_t. Since no measurements exist, the b matrix will have only zeros (already the case)
</span>
    <span class="c1"># Here we also define the uncertainty in prior is same as odom uncertainty
</span>    <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt_inv_odom</span> <span class="o">@</span> <span class="n">np</span><span class="p">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># no need to update b (already zeros)
</span>
    <span class="n">H_odom</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">A_fill_odom</span> <span class="o">=</span> <span class="n">sqrt_inv_odom</span> <span class="o">@</span> <span class="n">H_odom</span>

    <span class="c1"># TODO: Then fill in odometry measurements
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_odom</span><span class="p">):</span>
        <span class="c1"># declare an offset for i to include the prior term (which only occurs once along rows)
</span>        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>

        <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_fill_odom</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt_inv_odom</span> <span class="o">@</span> <span class="p">(</span><span class="n">odom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">odometry_estimation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>

    <span class="c1"># TODO: Then fill in landmark measurements
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_obs</span><span class="p">):</span>
        <span class="n">p_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">observations</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">l_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">observations</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">Al</span> <span class="o">=</span> <span class="n">sqrt_inv_obs</span> <span class="o">@</span> <span class="n">compute_meas_obs_jacobian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p_idx</span><span class="p">,</span> <span class="n">l_idx</span><span class="p">,</span> <span class="n">n_poses</span><span class="p">)</span>

        <span class="c1"># offset again to account for prior
</span>        <span class="n">j</span> <span class="o">=</span> <span class="n">n_odom</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">p_idx</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">p_idx</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Al</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n_poses</span><span class="o">+</span><span class="n">l_idx</span><span class="p">):</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n_poses</span><span class="o">+</span><span class="n">l_idx</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Al</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

        <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt_inv_obs</span> <span class="o">@</span> <span class="n">warp2pi</span><span class="p">(</span><span class="n">observations</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">bearing_range_estimation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">p_idx</span><span class="p">,</span><span class="n">l_idx</span><span class="p">,</span><span class="n">n_poses</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">b</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>

    <span class="n">n_poses</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gt_traj</span><span class="p">)</span>
    <span class="n">n_landmarks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gt_landmarks</span><span class="p">)</span>

    <span class="n">odom</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'odom'</span><span class="p">]</span>
    <span class="n">observations</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'observations'</span><span class="p">]</span>
    <span class="n">sigma_odom</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'sigma_odom'</span><span class="p">]</span>
    <span class="n">sigma_landmark</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'sigma_landmark'</span><span class="p">]</span>

    <span class="c1"># Initialize: non-linear optimization requires a good init.
</span>    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">args</span><span class="p">.</span><span class="n">method</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Applying </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
        <span class="n">traj</span><span class="p">,</span> <span class="n">landmarks</span> <span class="o">=</span> <span class="n">init_states</span><span class="p">(</span><span class="n">odom</span><span class="p">,</span> <span class="n">observations</span><span class="p">,</span> <span class="n">n_poses</span><span class="p">,</span> <span class="n">n_landmarks</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Before optimization'</span><span class="p">)</span>
        <span class="n">plot_traj_and_landmarks</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">landmarks</span><span class="p">,</span> <span class="n">gt_traj</span><span class="p">,</span> <span class="n">gt_landmarks</span><span class="p">)</span>

        <span class="c1"># Iterative optimization
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">vectorize_state</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">landmarks</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">create_linear_system</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">odom</span><span class="p">,</span> <span class="n">observations</span><span class="p">,</span> <span class="n">sigma_odom</span><span class="p">,</span>
                                        <span class="n">sigma_landmark</span><span class="p">,</span> <span class="n">n_poses</span><span class="p">,</span> <span class="n">n_landmarks</span><span class="p">)</span>
            <span class="n">dx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span>
        <span class="n">traj</span><span class="p">,</span> <span class="n">landmarks</span> <span class="o">=</span> <span class="n">devectorize_state</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_poses</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'After optimization'</span><span class="p">)</span>
        <span class="n">plot_traj_and_landmarks</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">landmarks</span><span class="p">,</span> <span class="n">gt_traj</span><span class="p">,</span> <span class="n">gt_landmarks</span><span class="p">)</span>

</code></pre></div></div>
      <h2 id="results">
        
        
          <a href="#results" class="anchor-heading" aria-labelledby="results"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Results
        
        
      </h2>
    

<p><img src="/images/SLAM/pose_graph/non_linear_results_1.png" alt="" />
<img src="/images/SLAM/pose_graph/non_linear_results_2.png" alt="" /></p>
      <h2 id="distinction-between-non-linear-and-linear-optimization">
        
        
          <a href="#distinction-between-non-linear-and-linear-optimization" class="anchor-heading" aria-labelledby="distinction-between-non-linear-and-linear-optimization"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Distinction between Non-Linear and Linear Optimization
        
        
      </h2>
    

<ul>
  <li>The Non Linear optimization process is different in that we have a residual h 0 term which causes the
optimizer to solve for the error between predicted and actual measurement. In the linear case the optimizer
directly solves for x in the equation Ax = b.</li>
  <li>Additionally, the non-linear method also requires a good initial estimate to start. This is because the
optimization is iterative for the non-linear case if the initialization is bad it will take longer or not converge
within the required error tolerance.</li>
</ul>

        

        

        
        
          <hr>
          <footer>
            

            <p class="text-small text-grey-dk-100 mb-0"></p>

            
              <div class="d-flex mt-2">
                
                
              </div>
            
          </footer>
        

      </div>
    </div>

    
      

      <div class="search-overlay"></div>
    
  </div>
</body>
</html>

