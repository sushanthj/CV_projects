

<!DOCTYPE html>

<html lang="en-US">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">

  <link rel="stylesheet" href="/assets/css/just-the-docs-default.css">

  <link rel="stylesheet" href="/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet">

  <style id="jtd-nav-activation">
  

    
    .site-nav > ul.nav-list:first-child > li:not(:nth-child(4)) > a,
    .site-nav > ul.nav-list:first-child > li > ul > li a {
      background-image: none;
    }

    .site-nav > ul.nav-list:not(:first-child) a,
    .site-nav li.external a {
      background-image: none;
    }

    .site-nav > ul.nav-list:first-child > li:nth-child(4) > a {
      font-weight: 600;
      text-decoration: none;
    }.site-nav > ul.nav-list:first-child > li:nth-child(4) > button svg {
      transform: rotate(-90deg);
    }.site-nav > ul.nav-list:first-child > li.nav-list-item:nth-child(4) > ul.nav-list {
      display: block;
    }
  </style>

  
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0VNMB6VPJF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      
        gtag('config', 'G-0VNMB6VPJF', { 'anonymize_ip': true });
      
    </script>
  

  
    <script src="/assets/js/vendor/lunr.min.js"></script>
  

  <script src="/assets/js/just-the-docs.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">

  



  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>3D Reconstruction | Navigating Robotics</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="3D Reconstruction" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Projects and assignments during my time in CMU" />
<meta property="og:description" content="Projects and assignments during my time in CMU" />
<link rel="canonical" href="http://localhost:4000/3D_reconstruction/" />
<meta property="og:url" content="http://localhost:4000/3D_reconstruction/" />
<meta property="og:site_name" content="Navigating Robotics" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="3D Reconstruction" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Projects and assignments during my time in CMU","headline":"3D Reconstruction","url":"http://localhost:4000/3D_reconstruction/"}</script>
<!-- End Jekyll SEO tag -->


  

</head>

<body>
  <a class="skip-to-main" href="#main-content">Skip to main content</a>
  <svg xmlns="http://www.w3.org/2000/svg" class="d-none">
  <symbol id="svg-link" viewBox="0 0 24 24">
  <title>Link</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link">
    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
  </svg>
</symbol>

  <symbol id="svg-menu" viewBox="0 0 24 24">
  <title>Menu</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
    <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
  </svg>
</symbol>

  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
  <title>Expand</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right">
    <polyline points="9 18 15 12 9 6"></polyline>
  </svg>
</symbol>

  <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE -->
<symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link">
  <title id="svg-external-link-title">(external link)</title>
  <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>
</symbol>

  
    <symbol id="svg-doc" viewBox="0 0 24 24">
  <title>Document</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file">
    <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>
  </svg>
</symbol>

    <symbol id="svg-search" viewBox="0 0 24 24">
  <title>Search</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search">
    <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>
  </svg>
</symbol>

  
  
    <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md -->
<symbol id="svg-copy" viewBox="0 0 16 16">
  <title>Copy</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16">
    <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
    <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
  </svg>
</symbol>
<symbol id="svg-copied" viewBox="0 0 16 16">
  <title>Copied</title>
  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16">
    <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/>
    <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/>
  </svg>
</symbol>

  
</svg>

  
    <div class="side-bar">
  <div class="site-header" role="banner">
    <a href="/" class="site-title lh-tight">
  Navigating Robotics

</a>
    <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false">
      <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg>
    </button>
  </div>

  <nav aria-label="Main" id="site-nav" class="site-nav">
  
  
    <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/intro/" class="nav-list-link">Building this Page</a></li><li class="nav-list-item"><a href="/planar_homography/" class="nav-list-link">Planar Homography</a></li><li class="nav-list-item"><a href="/3D_reconstruction/" class="nav-list-link">3D Reconstruction</a></li><li class="nav-list-item"><a href="/constr_rrt/" class="nav-list-link">Constrained RRT</a></li><li class="nav-list-item"><a href="/ConvNext/" class="nav-list-link">ConvNext</a></li><li class="nav-list-item"><a href="/mrsd_proj/" class="nav-list-link">MRSD Capstone Project</a></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Deep Learning category" aria-pressed="false">
        <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
      </button><a href="/docs/Deep%20Learning" class="nav-list-link">Deep Learning</a><ul class="nav-list"><li class="nav-list-item"><a href="/docs/Deep%20Learning/Basics.html" class="nav-list-link">ML Basics</a></li><li class="nav-list-item"><a href="/docs/Deep%20Learning/DL.html" class="nav-list-link">Deep Learning Starter</a></li><li class="nav-list-item"><a href="/docs/Deep%20Learning/IDL1.html" class="nav-list-link">MLPs (IDL1)</a></li><li class="nav-list-item"><a href="/docs/Deep%20Learning/IDL2.html" class="nav-list-link">Classifiers (IDL2)</a></li><li class="nav-list-item"><a href="/docs/Deep%20Learning/IDL3.html" class="nav-list-link">Optimizers and Regularizers (IDL3)</a></li><li class="nav-list-item"><a href="/docs/Deep%20Learning/IDL4.html" class="nav-list-link">Intro to CNNs</a></li><li class="nav-list-item"><a href="/docs/Deep%20Learning/IDL5.html" class="nav-list-link">Lessons Learnt 1</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in SLAM category" aria-pressed="false">
        <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
      </button><a href="/docs/SLAM" class="nav-list-link">SLAM</a><ul class="nav-list"><li class="nav-list-item"><a href="/docs/SLAM/Probability_review.html" class="nav-list-link">Recap on Probability</a></li><li class="nav-list-item"><a href="/docs/SLAM/Expectation_and_cov.html" class="nav-list-link">Expectation and Covariance</a></li><li class="nav-list-item"><a href="/docs/SLAM/Particle%20Filter_theory.html" class="nav-list-link">Particle Filters Theory</a></li><li class="nav-list-item"><a href="/docs/SLAM/EKF.html" class="nav-list-link">EKF</a></li><li class="nav-list-item"><a href="/docs/SLAM/Non_linear_slam.html" class="nav-list-link">Least Squares SLAM</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Computer Vision category" aria-pressed="false">
        <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
      </button><a href="/docs/Vision_General" class="nav-list-link">Computer Vision</a><ul class="nav-list"><li class="nav-list-item"><a href="/docs/Computer%20Vision/camera_model.html" class="nav-list-link">Camera Models and Projections</a></li><li class="nav-list-item"><a href="/docs/Computer%20Vision/Numpy.html" class="nav-list-link">Numpy for CV</a></li><li class="nav-list-item"><a href="/docs/Computer%20Vision/NERF.html" class="nav-list-link">Volume Rendering and NERFs</a></li><li class="nav-list-item"><a href="/docs/Computer%20Vision/bag_of_words.html" class="nav-list-link">Spatial Pyramids and Bag of Words</a></li><li class="nav-list-item"><a href="/docs/Computer%20Vision/Optical%20Flow.html" class="nav-list-link">Optical Flow and Image Alignment</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Computer Vision Libraries in C++ category" aria-pressed="false">
        <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg>
      </button><a href="/docs/Vision%20with%20C++" class="nav-list-link">Computer Vision Libraries in C++</a><ul class="nav-list"><li class="nav-list-item"><a href="/docs/Vision%20with%20C++/Eigen.html" class="nav-list-link">Linear Algebra in Eigen</a></li><li class="nav-list-item"><a href="/docs/Vision%20with%20C++/Eigen_applied.html" class="nav-list-link">Eigen, OpenCV, and Images</a></li></ul></li><li class="nav-list-item"><a href="/markdown-cheat-sheet.html" class="nav-list-link">Markdown Cheat Sheet</a></li></ul>
  
</nav>




  
  
    <footer class="site-footer">
      This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.
    </footer>
  
</div>

  
  <div class="main" id="top">
    <div id="main-header" class="main-header">
  
    

<div class="search" role="search">
  <div class="search-input-wrap">
    <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Navigating Robotics" aria-label="Search Navigating Robotics" autocomplete="off">
    <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label>
  </div>
  <div id="search-results" class="search-results"></div>
</div>

  
  
  
    <nav aria-label="Auxiliary" class="aux-nav">
  <ul class="aux-nav-list">
    
      <li class="aux-nav-list-item">
        <a href="//github.com/sushanthj" class="site-button"
          
        >
          Sushanth Jayanth's github
        </a>
      </li>
    
  </ul>
</nav>

  
</div>

    <div class="main-content-wrap">
      
      <div id="main-content" class="main-content">
        <main>
          
            <p><img src="/images/triangluation/35.png" alt="" /></p>

<details open="">
  <summary class="text-delta">
    Table of contents
  </summary>
<ol id="markdown-toc">
  <li><a href="#before-you-begin" id="markdown-toc-before-you-begin">Before you Begin</a></li>
  <li><a href="#pdfs" id="markdown-toc-pdfs">PDFs</a></li>
  <li><a href="#uses-of-mutli-view-geometry" id="markdown-toc-uses-of-mutli-view-geometry">Uses of Mutli-View Geometry</a></li>
  <li><a href="#background-structure-from-motion-sfm" id="markdown-toc-background-structure-from-motion-sfm">Background: Structure from Motion (SFM)</a></li>
  <li><a href="#theory-solving-for-camera-parameters-in-the-presence-of-scale-ambiguity" id="markdown-toc-theory-solving-for-camera-parameters-in-the-presence-of-scale-ambiguity">Theory: Solving for camera parameters in the presence of scale ambiguity</a>    <ol>
      <li><a href="#solving-for-camera-params-direct-linear-transform" id="markdown-toc-solving-for-camera-params-direct-linear-transform">Solving for Camera Params: Direct Linear Transform</a></li>
      <li><a href="#actual-derivation" id="markdown-toc-actual-derivation">Actual Derivation</a></li>
    </ol>
  </li>
  <li><a href="#theory-epipolar-geometry" id="markdown-toc-theory-epipolar-geometry">Theory: Epipolar Geometry</a>    <ol>
      <li><a href="#essential-matrix-maps-a-point---to-a-line" id="markdown-toc-essential-matrix-maps-a-point---to-a-line">Essential Matrix: Maps a point -&gt; to a line</a>        <ol>
          <li><a href="#derivation-of-essential-matrix-longuet-higgins" id="markdown-toc-derivation-of-essential-matrix-longuet-higgins">Derivation of Essential Matrix: Longuet Higgins</a>            <ol>
              <li><a href="#longuet-higgins-derivation" id="markdown-toc-longuet-higgins-derivation">Longuet Higgins Derivation</a></li>
            </ol>
          </li>
          <li><a href="#difference-between-essential-matrix-and-homography-matrix" id="markdown-toc-difference-between-essential-matrix-and-homography-matrix">Difference Between Essential Matrix and Homography Matrix</a></li>
          <li><a href="#how-does-this-essential-matrix-map-a-point-to-a-line-where-is-the-math" id="markdown-toc-how-does-this-essential-matrix-map-a-point-to-a-line-where-is-the-math">How does this Essential Matrix map a point to a line (where is the math?)</a></li>
        </ol>
      </li>
      <li><a href="#fundamental-matrix" id="markdown-toc-fundamental-matrix">Fundamental Matrix</a></li>
    </ol>
  </li>
  <li><a href="#structure-from-motion-step-1-estimating-fundamental-matrix" id="markdown-toc-structure-from-motion-step-1-estimating-fundamental-matrix">Structure From Motion Step 1: Estimating Fundamental Matrix:</a>    <ol>
      <li><a href="#estimate-essential-matrix-from-fundamental-matrix-given-k1-and-k2" id="markdown-toc-estimate-essential-matrix-from-fundamental-matrix-given-k1-and-k2">Estimate Essential Matrix from Fundamental Matrix (given K1 and K2)</a></li>
    </ol>
  </li>
  <li><a href="#triangulation" id="markdown-toc-triangulation">Triangulation</a>    <ol>
      <li><a href="#triangulate3d" id="markdown-toc-triangulate3d">triangulate3D</a></li>
      <li><a href="#using-triangulate-to-find-second-camera-matrix-after-fixing-first-camera-matrix--identity" id="markdown-toc-using-triangulate-to-find-second-camera-matrix-after-fixing-first-camera-matrix--identity">Using Triangulate to Find Second Camera Matrix after fixing First Camera Matrix = Identity</a></li>
      <li><a href="#combining-the-above-two-functions" id="markdown-toc-combining-the-above-two-functions">Combining the above two functions</a></li>
    </ol>
  </li>
  <li><a href="#bundle-adjustment" id="markdown-toc-bundle-adjustment">Bundle Adjustment</a>    <ol>
      <li><a href="#high-level-procedure" id="markdown-toc-high-level-procedure">High level procedure</a>        <ol>
          <li><a href="#rodriguesresidual-rodriguesresidualx-k1-m1-p1-k2-p2" id="markdown-toc-rodriguesresidual-rodriguesresidualx-k1-m1-p1-k2-p2">RodriguesResidual: <em>rodriguesResidual(x, K1, M1, p1, K2, p2)</em></a></li>
        </ol>
      </li>
      <li><a href="#optimization-of-m2" id="markdown-toc-optimization-of-m2">Optimization of M2</a></li>
    </ol>
  </li>
  <li><a href="#final-pipeline-including-ransac" id="markdown-toc-final-pipeline-including-ransac">Final Pipeline Including RANSAC</a>    <ol>
      <li><a href="#effects-of-ransac" id="markdown-toc-effects-of-ransac">Effects of RANSAC</a></li>
    </ol>
  </li>
  <li><a href="#tracking-real-world-objects-in-3d" id="markdown-toc-tracking-real-world-objects-in-3d">Tracking Real World Objects in 3D</a></li>
</ol>

</details>
<h2 id="before-you-begin">
  
  
    <a href="#before-you-begin" class="anchor-heading" aria-labelledby="before-you-begin"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Before you Begin
  
  
</h2>
    

<p><a href="https://drive.google.com/file/d/1jqEB739EfifhSyiCK6vdbPIz7gX9Ywmr/view?usp=sharing" class="btn fs-3 mb-4 mb-md-0">Reference Book 1</a>
<a href="https://drive.google.com/file/d/1Kn6dilDeR_7leIctuVa87-czuqBoxJh-/view?usp=sharing" class="btn fs-3 mb-4 mb-md-0">Reference Book 2</a></p>
<h2 id="pdfs">
  
  
    <a href="#pdfs" class="anchor-heading" aria-labelledby="pdfs"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> PDFs
  
  
</h2>
    

<p><a href="https://github.com/sushanthj/assignments_F22/blob/main/CV_A/Assignment_4/hw4.pdf" class="btn fs-3 mb-4 mb-md-0">Assignment Questionnaire</a></p>

<p><a href="https://github.com/sushanthj/assignments_F22/blob/main/CV_A/Assignment_4/code/for_sub/sushantj_hw4.pdf" class="btn fs-3 mb-4 mb-md-0">My Answers</a></p>
<h1 id="uses-of-mutli-view-geometry">
  
  
    <a href="#uses-of-mutli-view-geometry" class="anchor-heading" aria-labelledby="uses-of-mutli-view-geometry"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Uses of Mutli-View Geometry
  
  
</h1>
    

<p><img src="/images/triangluation/2.png" alt="" /></p>
<h1 id="background-structure-from-motion-sfm">
  
  
    <a href="#background-structure-from-motion-sfm" class="anchor-heading" aria-labelledby="background-structure-from-motion-sfm"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Background: Structure from Motion (SFM)
  
  
</h1>
    

<p>The basis for classical 3D vision is viewing an object from multiple views to give 3D understanding.</p>

<p>In humans, we don’t have to move to perceive 3D because our eyes(cameras) are already seperated
by a fixed distance. This is the same as having one camera move by a fixed distance. Hence, we
see “stereo depth vision”</p>
<h1 id="theory-solving-for-camera-parameters-in-the-presence-of-scale-ambiguity">
  
  
    <a href="#theory-solving-for-camera-parameters-in-the-presence-of-scale-ambiguity" class="anchor-heading" aria-labelledby="theory-solving-for-camera-parameters-in-the-presence-of-scale-ambiguity"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Theory: Solving for camera parameters in the presence of scale ambiguity
  
  
</h1>
    

<p>Remember we had the following equation:</p>

<p><img src="/images/triangluation/3.png" alt="" /></p>

<p>The lambda above is account for a scale factor which is ambiguous. This equation can also be
written as:</p>

<p><img src="/images/triangluation/4.png" alt="" /></p>
<h2 id="solving-for-camera-params-direct-linear-transform">
  
  
    <a href="#solving-for-camera-params-direct-linear-transform" class="anchor-heading" aria-labelledby="solving-for-camera-params-direct-linear-transform"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Solving for Camera Params: Direct Linear Transform
  
  
</h2>
    

<p>Now, the above equation is a similarity equation. To solve the equation we make use of a neat trick
called <strong>Direct Linear Transform</strong></p>

<p><img src="/images/triangluation/5.png" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">PX</code> should give the same ray (vector) as <code class="language-plaintext highlighter-rouge">x</code>, hence their cross product would be zero</p>
<h2 id="actual-derivation">
  
  
    <a href="#actual-derivation" class="anchor-heading" aria-labelledby="actual-derivation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Actual Derivation
  
  
</h2>
    

<p><img src="/images/triangluation/6.png" alt="" />
<img src="/images/triangluation/7.png" alt="" />
<img src="/images/triangluation/8.png" alt="" />
<img src="/images/triangluation/9.png" alt="" /></p>
<h1 id="theory-epipolar-geometry">
  
  
    <a href="#theory-epipolar-geometry" class="anchor-heading" aria-labelledby="theory-epipolar-geometry"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Theory: Epipolar Geometry
  
  
</h1>
    

<ul>
  <li><strong>Simply put, epipolar geometry maps a point in one view, to a line in another view</strong></li>
  <li>Epipolar Geometry is purely determined by camera intrinsics and camera extrinsics</li>
</ul>

<p><img src="/images/triangluation/12.png" alt="" /></p>

<p><img src="/images/triangluation/13.png" alt="" /></p>

<p><img src="/images/triangluation/14.png" alt="" /></p>
<h2 id="essential-matrix-maps-a-point---to-a-line">
  
  
    <a href="#essential-matrix-maps-a-point---to-a-line" class="anchor-heading" aria-labelledby="essential-matrix-maps-a-point---to-a-line"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Essential Matrix: Maps a point -&gt; to a line
  
  
</h2>
    

<p><img src="/images/triangluation/15.png" alt="" /></p>
<h3 id="derivation-of-essential-matrix-longuet-higgins">
  
  
    <a href="#derivation-of-essential-matrix-longuet-higgins" class="anchor-heading" aria-labelledby="derivation-of-essential-matrix-longuet-higgins"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Derivation of Essential Matrix: Longuet Higgins
  
  
</h3>
    

<ul>
  <li>
    <p><strong>Recall the skew-symmetric form of a matrix can encode cross products</strong></p>
  </li>
  <li>
    <p><img src="/images/triangluation/16.png" alt="" /></p>
  </li>
  <li>
    <p>We can use this to show how three vectors can define the volume of a parallelpiped:</p>
  </li>
  <li>
    <p><img src="/images/triangluation/17.png" alt="" /></p>
  </li>
  <li>
    <p>Now, given a calibrated camera (i.e. known intrinsics) we can capture a 3D point in two views</p>
  </li>
  <li>
    <p><img src="/images/triangluation/18.png" alt="" /></p>
  </li>
</ul>
<h4 id="longuet-higgins-derivation">
  
  
    <a href="#longuet-higgins-derivation" class="anchor-heading" aria-labelledby="longuet-higgins-derivation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Longuet Higgins Derivation
  
  
</h4>
    

<p><img src="/images/triangluation/19.png" alt="" /></p>

<p>The above derivation tells us in simplicity:</p>
<ul>
  <li>The volume of the parallelpiped (as seen previously is defined by a.(b x c)) is zero</li>
  <li>This means that three vectors are in one plane</li>
  <li>Which makes sense since the epipolar <strong>plane</strong> is what connects the 2 camera centers and the 3D point</li>
  <li><img src="/images/triangluation/20.png" alt="" /></li>
</ul>
<h3 id="difference-between-essential-matrix-and-homography-matrix">
  
  
    <a href="#difference-between-essential-matrix-and-homography-matrix" class="anchor-heading" aria-labelledby="difference-between-essential-matrix-and-homography-matrix"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Difference Between Essential Matrix and Homography Matrix
  
  
</h3>
    

<p><img src="/images/triangluation/21.png" alt="" /></p>
<h3 id="how-does-this-essential-matrix-map-a-point-to-a-line-where-is-the-math">
  
  
    <a href="#how-does-this-essential-matrix-map-a-point-to-a-line-where-is-the-math" class="anchor-heading" aria-labelledby="how-does-this-essential-matrix-map-a-point-to-a-line-where-is-the-math"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> How does this Essential Matrix map a point to a line (where is the math?)
  
  
</h3>
    

<p><img src="/images/triangluation/22.jpg" alt="" /></p>
<h2 id="fundamental-matrix">
  
  
    <a href="#fundamental-matrix" class="anchor-heading" aria-labelledby="fundamental-matrix"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Fundamental Matrix
  
  
</h2>
    

<p><img src="/images/triangluation/23.png" alt="" /></p>
<h1 id="structure-from-motion-step-1-estimating-fundamental-matrix">
  
  
    <a href="#structure-from-motion-step-1-estimating-fundamental-matrix" class="anchor-heading" aria-labelledby="structure-from-motion-step-1-estimating-fundamental-matrix"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Structure From Motion Step 1: Estimating Fundamental Matrix:
  
  
</h1>
    

<p><img src="/images/triangluation/24.png" alt="" /></p>

<p><img src="/images/triangluation/25.png" alt="" /></p>

<p><img src="/images/triangluation/26.png" alt="" /></p>

<p><img src="/images/triangluation/27.png" alt="" /></p><hr />

<p>We are given two images of the same object from two different views:</p>

<p><img src="/images/triangluation/im1.png" alt="" /> <img src="/images/triangluation/im2.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="s">'''
Q2.1: Eight Point Algorithm
    Input:  pts1, Nx2 Matrix
            pts2, Nx2 Matrix
            M, a scalar parameter computed as max (imwidth, imheight)
    Output: F, the fundamental matrix

    HINTS:
    (1) Normalize the input pts1 and pts2 using the matrix T.
    (2) Setup the eight point algorithm's equation.
    (3) Solve for the least square solution using SVD. 
    (4) Use the function `_singularize` (provided) to enforce the singularity condition. 
    (5) Use the function `refineF` (provided) to refine the computed fundamental matrix. 
        (Remember to usethe normalized points instead of the original points)
    (6) Unscale the fundamental matrix
'''</span>


<span class="k">def</span> <span class="nf">eightpoint</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> <span class="n">pts2</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
    <span class="s">"""
    Compute the normalized coordinates
    and also the fundamental matrix using computeH

    Args:
        x1 (Mx2): the matched locations of corners in img1
        x2 (Mx2): the matched locations of corners in img2

    Returns:
        F2to1: Fundamental matrix after denormalization
    """</span>
    <span class="c1"># Compute the centroid of the points
</span>    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">pts1</span><span class="p">,</span> <span class="n">pts2</span>

    <span class="c1"># Doing the M normaliazation
</span>    <span class="n">moved_scaled_x1</span> <span class="o">=</span> <span class="n">x1</span><span class="o">/</span><span class="n">M</span>
    <span class="n">moved_scaled_x2</span> <span class="o">=</span> <span class="n">x2</span><span class="o">/</span><span class="n">M</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">M</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Compute Fundamental Matrix
</span>    <span class="n">F</span> <span class="o">=</span> <span class="n">computeF</span><span class="p">(</span><span class="n">moved_scaled_x1</span><span class="p">,</span> <span class="n">moved_scaled_x2</span><span class="p">)</span>

    <span class="c1"># Refine and then enforce singularity constraint
</span>    <span class="n">F</span> <span class="o">=</span> <span class="n">_singularize</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">refineF</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">moved_scaled_x1</span><span class="p">,</span> <span class="n">moved_scaled_x2</span><span class="p">)</span>

    <span class="c1"># Denormalization
</span>    <span class="n">F2to1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="p">(</span><span class="n">F</span> <span class="o">@</span> <span class="n">t</span><span class="p">))</span>
    <span class="n">F2to1</span> <span class="o">=</span> <span class="n">F2to1</span><span class="o">/</span><span class="n">F2to1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">F2to1</span>


<span class="k">def</span> <span class="nf">computeF</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
    <span class="s">"""
    Computes the fundamental based on 
    matching points in both images

    Args:
        x1: keypoints in image 1
        x2: keypoints in image 2

    Returns:
        H2to1: the fundamental matrix
    """</span>

    <span class="c1"># Define a dummy H matrix
</span>    <span class="n">A_build</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Define the A matrix for (Ah = 0) (A matrix size = N*2 x 9)
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">row_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">A_build</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_1</span><span class="p">)</span>
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">stack</span><span class="p">(</span><span class="n">A_build</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Do the least squares minimization to get the homography matrix
</span>    <span class="c1"># this is done as eigenvector coresponding to smallest eigen value of A`A = H matrix
</span>    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="c1"># here the linalg.svd gives v_transpose
</span>    <span class="c1"># but we need just V therefore we again transpose
</span>    <span class="n">F2to1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">T</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">F2to1</span>


<span class="k">def</span> <span class="nf">check_and_create_directory</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">create</span><span class="p">):</span>
    <span class="s">"""
    Checks for existing directories and creates if unavailable

    [input]
    * dir_path : path to be checked
    * create   : tag to specify only checking path or also creating path
    """</span>
    <span class="k">if</span> <span class="n">create</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dir_path</span><span class="p">):</span>
            <span class="n">os</span><span class="p">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dir_path</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dir_path</span><span class="p">):</span>
            <span class="n">warnings</span><span class="p">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s">'following path could not be found: </span><span class="si">{</span><span class="n">dir_path</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>



<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
        
    <span class="n">correspondence</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">'data/some_corresp.npz'</span><span class="p">)</span> <span class="c1"># Loading correspondences
</span>    <span class="n">intrinsics</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">'data/intrinsics.npz'</span><span class="p">)</span> <span class="c1"># Loading the intrinscis of the camera
</span>    <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span> <span class="o">=</span> <span class="n">intrinsics</span><span class="p">[</span><span class="s">'K1'</span><span class="p">],</span> <span class="n">intrinsics</span><span class="p">[</span><span class="s">'K2'</span><span class="p">]</span>
    <span class="n">pts1</span><span class="p">,</span> <span class="n">pts2</span> <span class="o">=</span> <span class="n">correspondence</span><span class="p">[</span><span class="s">'pts1'</span><span class="p">],</span> <span class="n">correspondence</span><span class="p">[</span><span class="s">'pts2'</span><span class="p">]</span>
    <span class="n">im1</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'data/im1.png'</span><span class="p">)</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'data/im2.png'</span><span class="p">)</span>

    <span class="n">F</span> <span class="o">=</span> <span class="n">eightpoint</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> <span class="n">pts2</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nb">max</span><span class="p">([</span><span class="o">*</span><span class="n">im1</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">im2</span><span class="p">.</span><span class="n">shape</span><span class="p">]))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"the fundamental matrix found was </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>

    <span class="c1"># Q2.1
</span>    <span class="n">out_dir</span> <span class="o">=</span> <span class="s">"/home/sush/CMU/Assignment_Sem_1/CV_A/Assignment_4/code/outputs"</span>
    <span class="n">check_and_create_directory</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">np</span><span class="p">.</span><span class="n">savez_compressed</span><span class="p">(</span>
                        <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="s">'q2_1.npz'</span><span class="p">),</span>
                        <span class="n">F</span><span class="p">,</span>
                        <span class="n">np</span><span class="p">.</span><span class="nb">max</span><span class="p">([</span><span class="o">*</span><span class="n">im1</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">im2</span><span class="p">.</span><span class="n">shape</span><span class="p">])</span>
                        <span class="p">)</span>

    <span class="n">displayEpipolarF</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
</code></pre></div></div>

<p>Output:
<img src="/images/triangluation/28.png" alt="" /></p>
<h2 id="estimate-essential-matrix-from-fundamental-matrix-given-k1-and-k2">
  
  
    <a href="#estimate-essential-matrix-from-fundamental-matrix-given-k1-and-k2" class="anchor-heading" aria-labelledby="estimate-essential-matrix-from-fundamental-matrix-given-k1-and-k2"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Estimate Essential Matrix from Fundamental Matrix (given K1 and K2)
  
  
</h2>
    

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">'''
Q3.1: Compute the essential matrix E.
    Input:  F, fundamental matrix
            K1, internal camera calibration matrix of camera 1
            K2, internal camera calibration matrix of camera 2
    Output: E, the essential matrix
'''</span>
<span class="k">def</span> <span class="nf">essentialMatrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">):</span>
    <span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">K2</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">F</span><span class="p">)</span> <span class="o">@</span> <span class="n">K1</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">E</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"rank of E is"</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">E</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>

    <span class="n">correspondence</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">'data/some_corresp.npz'</span><span class="p">)</span> <span class="c1"># Loading correspondences
</span>    <span class="n">intrinsics</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">'data/intrinsics.npz'</span><span class="p">)</span> <span class="c1"># Loading the intrinscis of the camera
</span>    <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span> <span class="o">=</span> <span class="n">intrinsics</span><span class="p">[</span><span class="s">'K1'</span><span class="p">],</span> <span class="n">intrinsics</span><span class="p">[</span><span class="s">'K2'</span><span class="p">]</span>
    <span class="n">pts1</span><span class="p">,</span> <span class="n">pts2</span> <span class="o">=</span> <span class="n">correspondence</span><span class="p">[</span><span class="s">'pts1'</span><span class="p">],</span> <span class="n">correspondence</span><span class="p">[</span><span class="s">'pts2'</span><span class="p">]</span>
    <span class="n">im1</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'data/im1.png'</span><span class="p">)</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'data/im2.png'</span><span class="p">)</span>


    <span class="c1"># ----- TODO -----
</span>    <span class="c1"># YOUR CODE HERE
</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">eightpoint</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> <span class="n">pts2</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nb">max</span><span class="p">([</span><span class="o">*</span><span class="n">im1</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">im2</span><span class="p">.</span><span class="n">shape</span><span class="p">]))</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">essentialMatrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"E is </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
</code></pre></div></div>
<h1 id="triangulation">
  
  
    <a href="#triangulation" class="anchor-heading" aria-labelledby="triangulation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Triangulation
  
  
</h1>
    
<h2 id="triangulate3d">
  
  
    <a href="#triangulate3d" class="anchor-heading" aria-labelledby="triangulate3d"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> triangulate3D
  
  
</h2>
    

<ul>
  <li>Here we fix one camera (extrinsic matrix = Identity matrix). Now, we know correspondence points in image1 and image2.</li>
  <li>Using that we found the Fundamental Matrix</li>
</ul>

<p>Now, to estimate the 3D location of these points, we need</p>
<ol>
  <li>Camera matrices (extrinsic*intrinsic) for both cameras M1 and M2</li>
  <li>Image points (x,y) which correspond to each other</li>
  <li><a href="https://www.dropbox.com/sh/r569lhrgq9z4x7l/AACGDws-F4Krdwagm1F3-tnja?dl=0&amp;preview=L17+-+Camera+Models%2C+Pose+Estimation+and+Triangulation.pdf">Direct Linear Transform</a></li>
</ol>

<p>DLT was mentioned above, but small recap:
<img src="/images/triangluation/triangulation_setup.png" alt="" /></p>

<p><img src="/images/triangluation/triangulation_formula.png" alt="" /></p>

<p>After finding the 3D points, we will reproject them back onto the image and compare them with our original correspondence points (which we either manually selected or got from some keypoint detector like ORB or BRIEF)</p>

<p>The formula for reprojection error in this case is:</p>

<p><img src="/images/triangluation/1.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">triangulate</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">pts2</span><span class="p">):</span>
    <span class="s">"""
    Find the 3D coords of the keypoints

    We are given camera matrices and 2D correspondences.
    We can therefore find the 3D points (refer L17 (Camera Models) of CV slides)

    Note. We can't just use x = PX to compute the 3D point X because of scale ambiguity
          i.e the ambiguity can be rep. as x = alpha*Px (we cannot find alpha)
          Therefore we need to do DLT just like the case of homography 
          (see L14 (2D transforms) CVB slide 61)

    Args:
        C1   : the 3x4 camera matrix of camera 1
        pts1 : img coords of keypoints in camera 1 (Nx2)
        C2   : the 3x4 camera matrix of camera 2
        pts2 : img coords of keypoints in camera 2 (Nx2)

    Returns:
        P    : the estimated 3D point for the given pair of keypoint correspondences
        err  : the reprojection error
    """</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pts1</span><span class="p">)):</span>
        <span class="c1"># get the camera 1 matrix
</span>        <span class="n">p1_1</span> <span class="o">=</span> <span class="n">C1</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">p2_1</span> <span class="o">=</span> <span class="n">C1</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span>
        <span class="n">p3_1</span> <span class="o">=</span> <span class="n">C1</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span>

        <span class="c1"># get the camera 2 matrix
</span>        <span class="n">p1_2</span> <span class="o">=</span> <span class="n">C2</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">p2_2</span> <span class="o">=</span> <span class="n">C2</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span>
        <span class="n">p3_2</span> <span class="o">=</span> <span class="n">C2</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">pts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># calculate the A matrix for this point correspondence
</span>        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="o">*</span><span class="n">p3_1</span> <span class="o">-</span> <span class="n">p2_1</span> <span class="p">,</span> <span class="n">p1_1</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">p3_1</span> <span class="p">,</span> <span class="n">y2</span><span class="o">*</span><span class="n">p3_2</span> <span class="o">-</span> <span class="n">p2_2</span> <span class="p">,</span> <span class="n">p1_2</span> <span class="o">-</span> <span class="n">x2</span><span class="o">*</span><span class="n">p3_2</span><span class="p">])</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

        <span class="c1"># here the linalg.svd gives v_transpose
</span>        <span class="c1"># but we need just V therefore we again transpose
</span>        <span class="n">X</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">T</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># print("X is", X)
</span>        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">T</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># print("X after transpose and expand is", X)
</span>        
        <span class="c1"># convert X to homogenous coords
</span>        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">/</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1"># print("X after normalizing is", X)
</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">P</span><span class="p">,</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">T</span>

        <span class="c1"># find the error for this projection
</span>        <span class="c1"># 3x1 = 3x4 . 3x1 
</span>        <span class="n">pt_1</span> <span class="o">=</span> <span class="p">((</span><span class="n">C1</span> <span class="o">@</span> <span class="n">X</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">C1</span> <span class="o">@</span> <span class="n">X</span><span class="p">)[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pt_2</span> <span class="o">=</span> <span class="p">((</span><span class="n">C2</span> <span class="o">@</span> <span class="n">X</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">C2</span> <span class="o">@</span> <span class="n">X</span><span class="p">)[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># calculate the reporjection error
</span>        <span class="n">err</span> <span class="o">+=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pt_1</span> <span class="o">-</span> <span class="n">pts1</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pt_2</span> <span class="o">-</span> <span class="n">pts2</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"error in this iteration is"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
    <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">err</span>
</code></pre></div></div>

<p>Summary</p>
<ul>
  <li>Given two camera matrices and keypoint correspondences for two views, we triangulated the point (found 3D point)</li>
  <li>We found the reprojection error for this estimated 3D point</li>
</ul>
<h2 id="using-triangulate-to-find-second-camera-matrix-after-fixing-first-camera-matrix--identity">
  
  
    <a href="#using-triangulate-to-find-second-camera-matrix-after-fixing-first-camera-matrix--identity" class="anchor-heading" aria-labelledby="using-triangulate-to-find-second-camera-matrix-after-fixing-first-camera-matrix--identity"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Using Triangulate to Find Second Camera Matrix after fixing First Camera Matrix = Identity
  
  
</h2>
    
<p>Previsously we saw that we need an M2 to triangulate, but we don’t have an M2 yet :/.  <br />
However, since our first camera is fixed (identity) we can find the camera matrix M2 of our second camera as:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">camera2</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
    <span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">svd</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">S</span><span class="p">[:</span><span class="mi">2</span><span class="p">].</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">U</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])).</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">svd</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">det</span><span class="p">(</span><span class="n">U</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">).</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="o">-</span><span class="n">W</span>

    <span class="n">M2s</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">M2s</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">U</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">).</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">),</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">2</span><span class="p">].</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">U</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]).</span><span class="nb">max</span><span class="p">()],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">M2s</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">U</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">).</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">),</span> <span class="o">-</span><span class="n">U</span><span class="p">[:,</span><span class="mi">2</span><span class="p">].</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">U</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]).</span><span class="nb">max</span><span class="p">()],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">M2s</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">U</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">.</span><span class="n">T</span><span class="p">).</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">),</span> <span class="n">U</span><span class="p">[:,</span><span class="mi">2</span><span class="p">].</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">U</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]).</span><span class="nb">max</span><span class="p">()],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">M2s</span><span class="p">[:,:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">U</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">.</span><span class="n">T</span><span class="p">).</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">),</span> <span class="o">-</span><span class="n">U</span><span class="p">[:,</span><span class="mi">2</span><span class="p">].</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">U</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]).</span><span class="nb">max</span><span class="p">()],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">M2s</span>
</code></pre></div></div>

<p><strong>Note: The above function gives Four possible values for M2</strong></p>

<p>Why the 4 options?</p>

<p><img src="/images/triangluation/4cameras.jpg" alt="4 camera orientations" /></p>

<p>Now there are 2 checks we can use to find which is the right camera:</p>
<ul>
  <li>Determinant(Rotation component of M2) = 1 (so that the rotation belongs to SO(3))</li>
  <li>All Z values should be positive (i.e. the 3D point should be in front of both the cameras right?)</li>
</ul>
<h2 id="combining-the-above-two-functions">
  
  
    <a href="#combining-the-above-two-functions" class="anchor-heading" aria-labelledby="combining-the-above-two-functions"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Combining the above two functions
  
  
</h2>
    

<p>Now we have point correspondences, M1 and 4 M2’s. Therefore we’ll try to triangulate points based on 
the correct criteria for camera orientations. Additionally we’ll also try to minimize reprojection error:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># iterate over M1(fixed) and M2(4 possibilites) by passing them to triangulate
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M2</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
        <span class="n">M2_current</span> <span class="o">=</span> <span class="n">M2</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># build the C1 and C2:
</span>        <span class="n">pts_in_3d</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">triangulate</span><span class="p">((</span><span class="n">K1</span> <span class="o">@</span> <span class="n">M1</span><span class="p">),</span> <span class="n">pts1</span><span class="p">,</span> <span class="p">(</span><span class="n">K2</span> <span class="o">@</span> <span class="n">M2_current</span><span class="p">),</span> <span class="n">pts2</span><span class="p">)</span>    
        <span class="k">if</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="n">err_min</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">pts_in_3d</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"satisfies the error criteria"</span><span class="p">)</span>
            <span class="n">err_min</span> <span class="o">=</span> <span class="n">err</span>
            <span class="n">best_M2_i</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">best_pts_3d</span> <span class="o">=</span> <span class="n">pts_in_3d</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">best_M2_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">best_pts_3d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"min err is"</span><span class="p">,</span> <span class="n">err_min</span><span class="p">)</span>
        
        <span class="c1"># return M2, C2, w(3d points), M1, C1
</span>        <span class="k">return</span> <span class="n">M2</span><span class="p">[:,:,</span><span class="n">best_M2_i</span><span class="p">],</span> <span class="p">(</span><span class="n">K2</span> <span class="o">@</span> <span class="n">M2</span><span class="p">[:,:,</span><span class="n">best_M2_i</span><span class="p">]),</span> <span class="n">best_pts_3d</span><span class="p">,</span> <span class="n">M1</span><span class="p">,</span> <span class="p">(</span><span class="n">K1</span> <span class="o">@</span> <span class="n">M1</span><span class="p">)</span> <span class="c1"># last entry is C1
</span></code></pre></div></div>

<p><strong>Finally we all together have</strong>:</p>
<ul>
  <li><strong>our best_3d_points</strong></li>
  <li><strong>correct M2 matrix</strong></li>
</ul>

<p>Results of Triangulation on Input Images</p>

<p><img src="/images/triangluation/31.png" alt="" />
<img src="/images/triangluation/32.png" alt="" /></p>
<h1 id="bundle-adjustment">
  
  
    <a href="#bundle-adjustment" class="anchor-heading" aria-labelledby="bundle-adjustment"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Bundle Adjustment
  
  
</h1>
    

<p><img src="/images/triangluation/30.png" alt="" /></p>

<p>We know that the error in the triangulation is basically difference between the projection of a 3D point and the actual point in 2D on the image. Now, we will move around the 3D points slightly and check in which orientation the reprojection error comes to a global minimum.
The formula for the above operation is shown below:</p>

<p><img src="/images/triangluation/Bundle_formula.png" alt="" /></p>

<p>The process  we will follow now is very code specific. An explanation for only this below code is shown, where we will only be minimizing the rotation and translation (M2 matrix) error.</p>
<h3 id="high-level-procedure">
  
  
    <a href="#high-level-procedure" class="anchor-heading" aria-labelledby="high-level-procedure"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> High level procedure
  
  
</h3>
    

<ol>
  <li>Use the 2D point correspondences to find the Fundamental Matrix (along with RANSAC to find the inlier points)</li>
  <li>Use the <strong>inliers</strong> to find our best <strong>F</strong> (fundamental matrix)</li>
  <li>Compute an initial guess for M2 by using our old findM2 function</li>
  <li>Now, the above function would have given us 3D points <strong>(P_init)</strong> and an <strong>M2_init</strong></li>
  <li>Now, we have compiled the following:
    <ul>
      <li>M1 and K1</li>
      <li>M2_init and K2</li>
      <li>F and E <em>(E = (K2.T @ F) @ K1)</em></li>
    </ul>
  </li>
</ol>

<p>Having the above content, we will need to derive our reprojection error. We will do this in the RodriguesResidual function:</p>
<h4 id="rodriguesresidual-rodriguesresidualx-k1-m1-p1-k2-p2">
  
  
    <a href="#rodriguesresidual-rodriguesresidualx-k1-m1-p1-k2-p2" class="anchor-heading" aria-labelledby="rodriguesresidual-rodriguesresidualx-k1-m1-p1-k2-p2"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> RodriguesResidual: <em>rodriguesResidual(x, K1, M1, p1, K2, p2)</em>
  
  
</h4>
    

<ul>
  <li><strong>x</strong> basically contains the translation and rotation of camera2. We can therefore get M2 from x</li>
  <li>We can find the camera matrices <strong><em>C1 = K1 @ M1</em></strong>, <strong><em>C2 = K2 @ M2</em></strong></li>
</ul>

<p><img src="/images/triangluation/generic_projection_eq.png" alt="" /></p>

<ul>
  <li>Use the above equation to get p1’ and p2’</li>
  <li>Compare p1’ and p1, p2’ and p2, to get the reprojection error we need in both cameras</li>
</ul>

<p><img src="/images/triangluation/reproj_error_residuals.png" alt="" /></p>

<p><strong>Now we have a function which will give us reprojection error for a given M2 matrix. Now lets see how we’ll use this reporjection error to optimize our M2</strong></p>
<h3 id="optimization-of-m2">
  
  
    <a href="#optimization-of-m2" class="anchor-heading" aria-labelledby="optimization-of-m2"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Optimization of M2
  
  
</h3>
    

<p>Now that we have a function which will give us reprojection error for any given M2, lets minimize this error by <strong>moving around our 3D points slightly such that our reprojection error (for all points cumulative) reduces</strong></p>

<p>We do this using the scipy.optimize.minimize function</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># just some repackaging/preprocessing to give x to rodriguesResidual
</span><span class="n">x0</span> <span class="o">=</span> <span class="n">P_init</span><span class="p">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">r2_0</span><span class="p">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">t2_0</span><span class="p">.</span><span class="n">flatten</span><span class="p">())</span>

<span class="c1"># optimization step
</span><span class="n">x_opt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scipy</span><span class="p">.</span><span class="n">optimize</span><span class="p">.</span><span class="n">minimze</span><span class="p">(</span><span class="n">rodriguesResidual</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">K1</span><span class="p">,</span> <span class="n">M1</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">K2</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>Finally our x_opt i.e x_optimal will have the correct rotation and translation of camera 2 and the corrected 3D points</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">'''
Q5.3 Bundle adjustment.
    Input:  K1, the intrinsics of camera 1
            M1, the extrinsics of camera 1
            p1, the 2D coordinates of points in image 1
            K2,  the intrinsics of camera 2
            M2_init, the initial extrinsics of camera 1 (get this from findM2)
            p2, the 2D coordinates of points in image 2
            P_init, the initial 3D coordinates of points (get this also from findM2)
    Output: M2, the optimized extrinsics of camera 1
            P2, the optimized 3D coordinates of points
            o1, the starting objective function value with the initial input
            o2, the ending objective function value after bundle adjustment

    Hints:
    (1) Use the scipy.optimize.minimize function to minimize the objective function, rodriguesResidual. 
        You can try different (method='..') in scipy.optimize.minimize for best results. 
'''</span>
<span class="k">def</span> <span class="nf">bundleAdjustment</span><span class="p">(</span><span class="n">K1</span><span class="p">,</span> <span class="n">M1</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">K2</span><span class="p">,</span> <span class="n">M2_init</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">P_init</span><span class="p">):</span>
    
    <span class="c1"># given M2_init decompose it into R and t
</span>    <span class="n">R2</span> <span class="o">=</span> <span class="n">M2_init</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">M2_init</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">invRodrigues</span><span class="p">(</span><span class="n">R2</span><span class="p">)</span>

    <span class="n">x_start</span> <span class="o">=</span> <span class="n">P_init</span><span class="p">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">x_start</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">r2</span><span class="p">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">t2</span><span class="p">))</span>

    <span class="n">obj_start</span> <span class="o">=</span> <span class="n">rodriguesResidual</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">M1</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">K2</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"x_start shape is"</span><span class="p">,</span> <span class="n">x_start</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># optimization step
</span>    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
    <span class="n">x_optimized_obj</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">residual_norm</span><span class="p">,</span> <span class="n">x_start</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">K1</span><span class="p">,</span> <span class="n">M1</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">K2</span><span class="p">,</span> <span class="n">p2</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s">'Powell'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"x_end shape is"</span><span class="p">,</span> <span class="n">x_optimized_obj</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_optimized</span> <span class="o">=</span> <span class="n">x_optimized_obj</span><span class="p">.</span><span class="n">x</span>

    <span class="n">obj_end</span> <span class="o">=</span> <span class="n">rodriguesResidual</span><span class="p">(</span><span class="n">x_optimized</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">M1</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">K2</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>

    <span class="c1"># recompute the M2 and P
</span>    <span class="c1"># decompose x
</span>    <span class="n">P_final</span> <span class="o">=</span> <span class="n">x_optimized</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">P_shape_req</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">P_final</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">P_final</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">P_final</span><span class="p">,</span> <span class="n">newshape</span><span class="o">=</span><span class="p">(</span><span class="n">P_shape_req</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    
    <span class="n">r2_final</span> <span class="o">=</span> <span class="n">x_optimized</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
    <span class="c1"># reshape to 3x1 to feed to inverse rodrigues
</span>    <span class="n">r2_final</span> <span class="o">=</span> <span class="n">r2_final</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># reshape translation matrix to combine in transformation matrix
</span>    <span class="n">t2_final</span> <span class="o">=</span> <span class="n">x_optimized</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:].</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># compose the C2 matrix
</span>    <span class="n">R2_final</span> <span class="o">=</span> <span class="n">rodrigues</span><span class="p">(</span><span class="n">r2_final</span><span class="p">)</span>
    <span class="n">M2_final</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">R2_final</span><span class="p">,</span> <span class="n">t2_final</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">M2_final</span><span class="p">,</span> <span class="n">P_final</span><span class="p">,</span> <span class="n">obj_start</span><span class="p">,</span> <span class="n">obj_end</span>
</code></pre></div></div>

<p>Results on optimizing points after bundle adjustment</p>

<p><img src="/images/triangluation/33.png" alt="" /></p>
<h1 id="final-pipeline-including-ransac">
  
  
    <a href="#final-pipeline-including-ransac" class="anchor-heading" aria-labelledby="final-pipeline-including-ransac"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Final Pipeline Including RANSAC
  
  
</h1>
    

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
              
    <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#Added for testing, can be commented out
</span>
    <span class="n">some_corresp_noisy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">'data/some_corresp_noisy.npz'</span><span class="p">)</span> <span class="c1"># Loading correspondences
</span>    <span class="n">intrinsics</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">'data/intrinsics.npz'</span><span class="p">)</span> <span class="c1"># Loading the intrinscis of the camera
</span>    <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span> <span class="o">=</span> <span class="n">intrinsics</span><span class="p">[</span><span class="s">'K1'</span><span class="p">],</span> <span class="n">intrinsics</span><span class="p">[</span><span class="s">'K2'</span><span class="p">]</span>
    <span class="n">noisy_pts1</span><span class="p">,</span> <span class="n">noisy_pts2</span> <span class="o">=</span> <span class="n">some_corresp_noisy</span><span class="p">[</span><span class="s">'pts1'</span><span class="p">],</span> <span class="n">some_corresp_noisy</span><span class="p">[</span><span class="s">'pts2'</span><span class="p">]</span>
    <span class="n">im1</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'data/im1.png'</span><span class="p">)</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'data/im2.png'</span><span class="p">)</span>

    <span class="n">templeCoords</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">'data/templeCoords.npz'</span><span class="p">)</span>
    <span class="n">temple_pts1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">templeCoords</span><span class="p">[</span><span class="s">"x1"</span><span class="p">],</span> <span class="n">templeCoords</span><span class="p">[</span><span class="s">"y1"</span><span class="p">]])</span>

    <span class="c1">#? getting the F matrix from noisy correspondences
</span>    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">max</span><span class="p">([</span><span class="o">*</span><span class="n">im1</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">im2</span><span class="p">.</span><span class="n">shape</span><span class="p">])</span>

    <span class="n">F</span><span class="p">,</span> <span class="n">inliers</span> <span class="o">=</span> <span class="n">ransacF</span><span class="p">(</span><span class="n">noisy_pts1</span><span class="p">,</span> <span class="n">noisy_pts2</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">)</span>
    <span class="n">inlier_pts1</span><span class="p">,</span> <span class="n">inlier_pts2</span> <span class="o">=</span> <span class="n">inliers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inliers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"shape of noisy_pts1 is"</span><span class="p">,</span> <span class="n">noisy_pts1</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"shape of inlier_pts1 is"</span><span class="p">,</span> <span class="n">inlier_pts1</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">F_naieve</span> <span class="o">=</span> <span class="n">eightpoint</span><span class="p">(</span><span class="n">noisy_pts1</span><span class="p">,</span> <span class="n">noisy_pts2</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

    <span class="c1"># use displayEpipolarF to compare how ransac_F and naieve_F behave
</span>    <span class="c1"># displayEpipolarF(im1, im2, F)
</span>    <span class="c1"># displayEpipolarF(im1, im2, F_naieve)
</span>
    <span class="c1"># Simple Tests to verify your implementation:
</span>    <span class="kn">from</span> <span class="nn">scipy.spatial.transform</span> <span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">sRot</span>
    <span class="n">rotVec</span> <span class="o">=</span> <span class="n">sRot</span><span class="p">.</span><span class="n">random</span><span class="p">()</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">rodrigues</span><span class="p">(</span><span class="n">rotVec</span><span class="p">.</span><span class="n">as_rotvec</span><span class="p">())</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rotVec</span><span class="p">.</span><span class="n">as_rotvec</span><span class="p">()</span> <span class="o">-</span> <span class="n">invRodrigues</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">)</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rotVec</span><span class="p">.</span><span class="n">as_matrix</span><span class="p">()</span> <span class="o">-</span> <span class="n">mat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">)</span>

    <span class="c1">#? Getting the initial guess for M2 and P
</span>    <span class="c1"># Assuming the rotation and translation of camera1 is zero
</span>    <span class="n">M1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">M2_init</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">P_init</span><span class="p">,</span> <span class="n">M1</span><span class="p">,</span> <span class="n">C1</span> <span class="o">=</span> <span class="n">findM2</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">inlier_pts1</span><span class="p">,</span> <span class="n">inlier_pts2</span><span class="p">,</span> <span class="n">intrinsics</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"M2 shape is"</span><span class="p">,</span> <span class="n">M2_init</span><span class="p">)</span>

    <span class="c1"># Optimize the M2
</span>    <span class="n">M2_final</span><span class="p">,</span> <span class="n">P_final</span><span class="p">,</span> <span class="n">start_obj</span><span class="p">,</span> <span class="n">end_obj</span> <span class="o">=</span> <span class="n">bundleAdjustment</span><span class="p">(</span>
                                                            <span class="n">K1</span><span class="p">,</span> 
                                                            <span class="n">M1</span><span class="p">,</span> 
                                                            <span class="n">inlier_pts1</span><span class="p">,</span> 
                                                            <span class="n">K2</span><span class="p">,</span> 
                                                            <span class="n">M2_init</span><span class="p">,</span> 
                                                            <span class="n">inlier_pts2</span><span class="p">,</span> 
                                                            <span class="n">P_init</span>
                                                            <span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"error before optimization is"</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">start_obj</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"error after optimization is"</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">end_obj</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># compare the old M2 to optimized M2
</span>    <span class="n">plot_3D_dual</span><span class="p">(</span><span class="n">P_init</span><span class="p">,</span> <span class="n">P_final</span><span class="p">)</span>
</code></pre></div></div>
<h2 id="effects-of-ransac">
  
  
    <a href="#effects-of-ransac" class="anchor-heading" aria-labelledby="effects-of-ransac"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Effects of RANSAC
  
  
</h2>
    

<p>RANSAC was used even before bundle adjustment, to remove noisy coorespondences for the
initial best gues of the Fundamental Matrix.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ransacF</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> <span class="n">pts2</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">nIters</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="s">"""
    Every iteration we init a Fundamental matrix using 4 corresponding
    points and calculate number of inliers. Finally use the Homography
    matrix which had max number of inliers (and these inliers as well)
    to find the final Fundamental matrix
    Args:
        pts1: location of matched points in image1
        pts2: location of matched points in image2
        opts: user inputs used for distance tolerance in ransac

    Returns:
        bestH2to1     : The Fundamental matrix with max number of inliers
        inlier_points : Final list of inliers found for best RANSAC iteration
    """</span>
    <span class="n">max_iters</span> <span class="o">=</span> <span class="n">nIters</span> <span class="c1"># the number of iterations to run RANSAC for
</span>    <span class="n">inlier_tol</span> <span class="o">=</span> <span class="n">tol</span> <span class="c1"># the tolerance value for considering a point to be an inlier
</span>    <span class="n">locs1</span> <span class="o">=</span> <span class="n">pts1</span>
    <span class="n">locs2</span> <span class="o">=</span> <span class="n">pts2</span>

    <span class="c1"># define size of both locs1 and locs2
</span>    <span class="n">num_rows</span> <span class="o">=</span> <span class="n">locs1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># define a container for keeping track of inlier counts
</span>    <span class="n">final_inlier_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">final_distance_error</span> <span class="o">=</span> <span class="mi">10000000000</span>

    <span class="c1">#? Create a boolean vector of length N where 1 = inlier and 0 = outlier
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Computing RANSAC"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iters</span><span class="p">):</span>
        <span class="n">test_locs1</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">locs1</span><span class="p">)</span>
        <span class="n">test_locs2</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">locs2</span><span class="p">)</span>
        <span class="c1"># chose a random sample of 4 points to find H
</span>        <span class="n">rand_index</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">rand_index</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">locs1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">k</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
        
        <span class="n">rand_points_1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rand_points_2</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">rand_index</span><span class="p">:</span>
            <span class="n">rand_points_1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">locs1</span><span class="p">[</span><span class="n">j</span><span class="p">,:])</span>
            <span class="n">rand_points_2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">locs2</span><span class="p">[</span><span class="n">j</span><span class="p">,:])</span>
        
        <span class="n">test_locs1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">test_locs1</span><span class="p">,</span> <span class="n">rand_index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">test_locs2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">test_locs2</span><span class="p">,</span> <span class="n">rand_index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
        <span class="n">correspondence_points_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">rand_points_1</span><span class="p">)</span>
        <span class="n">correspondence_points_2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">rand_points_2</span><span class="p">)</span>

        <span class="n">ref_F</span> <span class="o">=</span> <span class="n">eightpoint</span><span class="p">(</span><span class="n">correspondence_points_1</span><span class="p">,</span> <span class="n">correspondence_points_2</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="n">inliers</span><span class="p">,</span> <span class="n">inlier_count</span><span class="p">,</span> <span class="n">distance_error</span><span class="p">,</span> <span class="n">error_state</span> <span class="o">=</span> <span class="n">compute_inliers</span><span class="p">(</span><span class="n">ref_F</span><span class="p">,</span> 
                                                                            <span class="n">test_locs1</span><span class="p">,</span>
                                                                            <span class="n">test_locs2</span><span class="p">,</span> 
                                                                            <span class="n">inlier_tol</span><span class="p">,</span>
                                                                            <span class="n">im1</span><span class="p">,</span>
                                                                            <span class="n">im2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">error_state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">inlier_count</span> <span class="o">&gt;</span> <span class="n">final_inlier_count</span><span class="p">):</span>
            <span class="n">final_inlier_count</span> <span class="o">=</span> <span class="n">inlier_count</span>
            <span class="n">final_inliers</span> <span class="o">=</span> <span class="n">inliers</span>
            <span class="n">final_corresp_points_1</span> <span class="o">=</span> <span class="n">correspondence_points_1</span>
            <span class="n">final_corresp_points_2</span> <span class="o">=</span> <span class="n">correspondence_points_2</span>
            <span class="n">final_distance_error</span> <span class="o">=</span> <span class="n">distance_error</span>
            <span class="n">final_test_locs1</span> <span class="o">=</span> <span class="n">test_locs1</span>
            <span class="n">final_test_locs2</span> <span class="o">=</span> <span class="n">test_locs2</span>
        
    <span class="k">if</span> <span class="n">final_distance_error</span> <span class="o">!=</span> <span class="mi">100000000</span><span class="p">:</span>
        <span class="c1"># print("original point count is", locs1.shape[0])
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"final inlier count is"</span><span class="p">,</span> <span class="n">final_inlier_count</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"final inlier's cumulative distance error is"</span><span class="p">,</span> <span class="n">final_distance_error</span><span class="p">)</span>

        <span class="n">delete_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">final_inliers</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">final_locs_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">final_test_locs1</span><span class="p">,</span> <span class="n">delete_indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">final_locs_2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">final_test_locs2</span><span class="p">,</span> <span class="n">delete_indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">final_locs_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">final_locs_1</span><span class="p">,</span> <span class="n">final_corresp_points_1</span><span class="p">))</span>
        <span class="n">final_locs_2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">final_locs_2</span><span class="p">,</span> <span class="n">final_corresp_points_2</span><span class="p">))</span>

        <span class="n">bestH2to1</span> <span class="o">=</span> <span class="n">eightpoint</span><span class="p">(</span><span class="n">final_locs_1</span><span class="p">,</span> <span class="n">final_locs_2</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bestH2to1</span><span class="p">,</span> <span class="p">[</span><span class="n">final_locs_1</span><span class="p">,</span> <span class="n">final_locs_2</span><span class="p">]</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"SOMETHING WRONG"</span><span class="p">)</span>
        <span class="n">bestH2to1</span> <span class="o">=</span> <span class="n">eightpoint</span><span class="p">(</span><span class="n">correspondence_points_1</span><span class="p">,</span> <span class="n">correspondence_points_2</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bestH2to1</span><span class="p">,</span> <span class="mi">0</span>
</code></pre></div></div>

<p><img src="/images/triangluation/34.png" alt="" /></p>
<h1 id="tracking-real-world-objects-in-3d">
  
  
    <a href="#tracking-real-world-objects-in-3d" class="anchor-heading" aria-labelledby="tracking-real-world-objects-in-3d"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Tracking Real World Objects in 3D
  
  
</h1>
    

<p><img src="/images/triangluation/35.png" alt="" /></p>

<p><img src="/images/triangluation/36.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">'''
Q6.1 Multi-View Reconstruction of keypoints.
    Input:  C1, the 3x4 camera matrix
            pts1, the Nx3 matrix with the 2D image coordinates and confidence per row
            C2, the 3x4 camera matrix
            pts2, the Nx3 matrix with the 2D image coordinates and confidence per row
            C3, the 3x4 camera matrix
            pts3, the Nx3 matrix with the 2D image coordinates and confidence per row
    Output: P, the Nx3 matrix with the corresponding 3D points for each keypoint per row
            err, the reprojection error.
'''</span>
<span class="k">def</span> <span class="nf">MultiviewReconstruction</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">pts2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">pts3</span><span class="p">,</span> <span class="n">Thres</span> <span class="o">=</span> <span class="mi">200</span><span class="p">):</span>
    <span class="n">vis_pts_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">pts1</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Thres</span><span class="p">)</span>
    <span class="n">vis_pts_2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">pts2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Thres</span><span class="p">)</span>
    <span class="n">vis_pts_3</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">pts3</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Thres</span><span class="p">)</span>
    
    <span class="c1"># create a dummy vector to save the 3D points for each corresp 2D pt
</span>    <span class="n">pts_3d</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">pts1</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">reproj_error</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>

    <span class="n">overlap_all</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">vis_pts_1</span><span class="p">,</span> <span class="n">vis_pts_2</span><span class="p">,</span> <span class="n">vis_pts_3</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">overlap_all</span><span class="p">:</span>
        <span class="n">pts_cam_1_2</span><span class="p">,</span> <span class="n">err1</span> <span class="o">=</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C2</span><span class="p">,</span> <span class="n">pts2</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">pts_cam_2_3</span><span class="p">,</span> <span class="n">err2</span> <span class="o">=</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">C2</span><span class="p">,</span> <span class="n">pts2</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C3</span><span class="p">,</span> <span class="n">pts3</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">pts_cam_1_3</span><span class="p">,</span> <span class="n">err3</span> <span class="o">=</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C3</span><span class="p">,</span> <span class="n">pts3</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">avg_pt_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">pts_cam_1_2</span> <span class="o">+</span> <span class="n">pts_cam_2_3</span> <span class="o">+</span> <span class="n">pts_cam_1_3</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span>
        <span class="n">avg_err</span> <span class="o">=</span> <span class="p">(</span><span class="n">err1</span><span class="o">+</span><span class="n">err2</span><span class="o">+</span><span class="n">err3</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span>
        <span class="n">pts_3d</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">avg_pt_i</span>
        <span class="n">reproj_error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">avg_err</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vis_pts_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># print("i is", i)
</span>        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">overlap_all</span><span class="p">:</span>
            <span class="c1"># print("computing", i)
</span>            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vis_pts_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">pts_i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C2</span><span class="p">,</span> <span class="n">pts2</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">pts_3d</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pts_i</span>
                <span class="n">reproj_error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vis_pts_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">pts_i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C3</span><span class="p">,</span> <span class="n">pts3</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">pts_3d</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pts_i</span>
                <span class="n">reproj_error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"point not visible in 2 views"</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vis_pts_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># print("i is", i)
</span>        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">overlap_all</span><span class="p">:</span>
            <span class="c1"># print("computing", i)
</span>            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vis_pts_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">pts_i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">C2</span><span class="p">,</span> <span class="n">pts2</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C3</span><span class="p">,</span> <span class="n">pts3</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">pts_3d</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pts_i</span>
                <span class="n">reproj_error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vis_pts_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">pts_i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C2</span><span class="p">,</span> <span class="n">pts2</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">pts_3d</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pts_i</span>
                <span class="n">reproj_error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"point not visible in 2 views"</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vis_pts_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">overlap_all</span><span class="p">:</span>
            <span class="c1"># print("computing", i)
</span>            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vis_pts_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">pts_i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C3</span><span class="p">,</span> <span class="n">pts3</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">pts_3d</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pts_i</span>
                <span class="n">reproj_error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vis_pts_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">pts_i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">C2</span><span class="p">,</span> <span class="n">pts2</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">pts_3d</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pts_i</span>
                <span class="n">reproj_error</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">"point not visible in 2 views"</span><span class="p">)</span>
    
    <span class="k">print</span><span class="p">(</span><span class="s">"pts1 shape is"</span><span class="p">,</span> <span class="n">pts1</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"3d points shape is"</span><span class="p">,</span> <span class="n">pts_3d</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pts_3d</span><span class="p">,</span> <span class="n">reproj_error</span><span class="p">,</span> <span class="p">[</span><span class="n">vis_pts_1</span><span class="p">,</span> <span class="n">vis_pts_2</span><span class="p">,</span> <span class="n">vis_pts_3</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">MutliviewReconstructionError</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">pts2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">pts3</span><span class="p">,</span> <span class="n">vis_pts_list</span><span class="p">):</span>
    <span class="c1"># decompose x
</span>    <span class="n">P_init</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">P_shape_req</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">P_init</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">P_init</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">P_init</span><span class="p">,</span> <span class="n">newshape</span><span class="o">=</span><span class="p">(</span><span class="n">P_shape_req</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    
    <span class="n">vis_pts_1</span> <span class="o">=</span> <span class="n">vis_pts_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">vis_pts_2</span> <span class="o">=</span> <span class="n">vis_pts_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">vis_pts_3</span> <span class="o">=</span> <span class="n">vis_pts_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">pts1</span> <span class="o">=</span> <span class="n">pts1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">pts2</span> <span class="o">=</span> <span class="n">pts2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">pts3</span> <span class="o">=</span> <span class="n">pts3</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># list to store error values
</span>    <span class="n">err_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># build a sub_P matrix for all visible points in pts1, pts2, pts3
</span>    <span class="n">sub_pts1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">pts1</span><span class="p">,</span> <span class="n">vis_pts_1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sub_P1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">P_init</span><span class="p">,</span> <span class="n">vis_pts_1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sub_pts2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">pts2</span><span class="p">,</span> <span class="n">vis_pts_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sub_P2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">P_init</span><span class="p">,</span> <span class="n">vis_pts_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sub_pts3</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">pts3</span><span class="p">,</span> <span class="n">vis_pts_3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sub_P3</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">P_init</span><span class="p">,</span> <span class="n">vis_pts_3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">P_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_P1</span><span class="p">,</span> <span class="n">sub_P2</span><span class="p">,</span> <span class="n">sub_P3</span><span class="p">]</span>
    <span class="n">pts_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_pts1</span><span class="p">,</span> <span class="n">sub_pts2</span><span class="p">,</span> <span class="n">sub_pts3</span><span class="p">]</span>
    <span class="n">C_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">P_list</span><span class="p">)):</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">P_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">p</span><span class="o">=</span> <span class="n">pts_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">C_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1"># homogenize P to contain a 1 in the end (P = Nx3 vector)
</span>        <span class="n">P_homogenous</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="n">P</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># Find the projection of P1 onto image 1 (vectorize)
</span>        <span class="c1"># Transpose P_homogenous to make it a 4xN vector and left mulitply with C1
</span>        <span class="c1">#  3xN =  3x4 @ 4XN
</span>        <span class="n">p_hat</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span> <span class="o">@</span> <span class="n">P_homogenous</span><span class="p">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># normalize and transpose to get back to format of p1
</span>        <span class="n">p_hat</span> <span class="o">=</span> <span class="p">((</span><span class="n">p_hat</span><span class="o">/</span><span class="n">p_hat</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,:]).</span><span class="n">T</span>

        <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">((</span><span class="n">p</span><span class="o">-</span><span class="n">p_hat</span><span class="p">).</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">err_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
    
    <span class="n">err_total</span> <span class="o">=</span> <span class="n">err_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">err_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">err_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># print("error overall is", err_total)
</span>
    <span class="k">return</span> <span class="n">err_total</span>
    
<span class="k">def</span> <span class="nf">triangulate</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">pts2</span><span class="p">):</span>
    <span class="s">"""
    Find the 3D coords of the keypoints

    We are given camera matrices and 2D correspondences.
    We can therefore find the 3D points (refer L17 (Camera Models) of CV slides)

    Note. We can't just use x = PX to compute the 3D point X because of scale ambiguity
          i.e the ambiguity can be rep. as x = alpha*Px (we cannot find alpha)
          Therefore we need to do DLT just like the case of homography 
          (see L14 (2D transforms) CVB slide 61)

    Args:
        C1   : the 3x4 camera matrix of camera 1
        pts1 : img coords of keypoints in camera 1 (Nx2)
        C2   : the 3x4 camera matrix of camera 2
        pts2 : img coords of keypoints in camera 2 (Nx2)

    Returns:
        P    : the estimated 3D point for the given pair of keypoint correspondences
        err  : the reprojection error
    """</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="c1"># get the camera 1 matrix
</span>    <span class="n">p1_1</span> <span class="o">=</span> <span class="n">C1</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">p2_1</span> <span class="o">=</span> <span class="n">C1</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span>
    <span class="n">p3_1</span> <span class="o">=</span> <span class="n">C1</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span>

    <span class="c1"># get the camera 2 matrix
</span>    <span class="n">p1_2</span> <span class="o">=</span> <span class="n">C2</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">p2_2</span> <span class="o">=</span> <span class="n">C2</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span>
    <span class="n">p3_2</span> <span class="o">=</span> <span class="n">C2</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pts1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">pts2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># calculate the A matrix for this point correspondence
</span>    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="o">*</span><span class="n">p3_1</span> <span class="o">-</span> <span class="n">p2_1</span> <span class="p">,</span> <span class="n">p1_1</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">p3_1</span> <span class="p">,</span> <span class="n">y2</span><span class="o">*</span><span class="n">p3_2</span> <span class="o">-</span> <span class="n">p2_2</span> <span class="p">,</span> <span class="n">p1_2</span> <span class="o">-</span> <span class="n">x2</span><span class="o">*</span><span class="n">p3_2</span><span class="p">])</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="c1"># here the linalg.svd gives v_transpose
</span>    <span class="c1"># but we need just V therefore we again transpose
</span>    <span class="n">X</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">T</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># print("X is", X)
</span>    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">T</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># print("X after transpose and expand is", X)
</span>    
    <span class="c1"># convert X to homogenous coords
</span>    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">/</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
    <span class="c1"># print("X after normalizing is", X)
</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">P</span><span class="p">,</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">T</span>

    <span class="c1"># find the error for this projection
</span>    <span class="c1"># 3x1 = 3x4 . 3x1 
</span>    <span class="n">pt_1</span> <span class="o">=</span> <span class="p">((</span><span class="n">C1</span> <span class="o">@</span> <span class="n">X</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">C1</span> <span class="o">@</span> <span class="n">X</span><span class="p">)[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pt_2</span> <span class="o">=</span> <span class="p">((</span><span class="n">C2</span> <span class="o">@</span> <span class="n">X</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">C2</span> <span class="o">@</span> <span class="n">X</span><span class="p">)[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># calculate the reporjection error
</span>    <span class="n">err</span> <span class="o">+=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pt_1</span> <span class="o">-</span> <span class="n">pts1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pt_2</span> <span class="o">-</span> <span class="n">pts2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># print("error in this iteration is", err)
</span>    <span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
    <span class="k">return</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">err</span>

<span class="s">'''
Q6.2 Plot Spatio-temporal (3D) keypoints
    :param car_points: np.array points * 3
'''</span>
<span class="k">def</span> <span class="nf">plot_3d_keypoint_video</span><span class="p">(</span><span class="n">pts_3d_video</span><span class="p">):</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="c1"># num_points = pts_3d.shape[0]
</span>    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="p">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s">'3d'</span><span class="p">)</span>

    <span class="n">vid_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts_3d_video</span><span class="p">)</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">vid_len</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pts_3d_video</span><span class="p">)):</span>
        <span class="n">pts_3d</span> <span class="o">=</span> <span class="n">pts_3d_video</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">connections_3d</span><span class="p">)):</span>
            <span class="n">index0</span><span class="p">,</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">connections_3d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">xline</span> <span class="o">=</span> <span class="p">[</span><span class="n">pts_3d</span><span class="p">[</span><span class="n">index0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pts_3d</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">yline</span> <span class="o">=</span> <span class="p">[</span><span class="n">pts_3d</span><span class="p">[</span><span class="n">index0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">pts_3d</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">zline</span> <span class="o">=</span> <span class="p">[</span><span class="n">pts_3d</span><span class="p">[</span><span class="n">index0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">pts_3d</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xline</span><span class="p">,</span> <span class="n">yline</span><span class="p">,</span> <span class="n">zline</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">np</span><span class="p">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'X Label'</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'Y Label'</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s">'Z Label'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


<span class="c1">#Extra Credit
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
         
    <span class="n">pts_3d_video</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"processing time frame - </span><span class="si">{</span><span class="n">loop</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

        <span class="n">data_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">'data/q6/'</span><span class="p">,</span><span class="s">'time'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span><span class="o">+</span><span class="s">'.npz'</span><span class="p">)</span>
        <span class="n">image1_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">'data/q6/'</span><span class="p">,</span><span class="s">'cam1_time'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span><span class="o">+</span><span class="s">'.jpg'</span><span class="p">)</span>
        <span class="n">image2_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">'data/q6/'</span><span class="p">,</span><span class="s">'cam2_time'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span><span class="o">+</span><span class="s">'.jpg'</span><span class="p">)</span>
        <span class="n">image3_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">'data/q6/'</span><span class="p">,</span><span class="s">'cam3_time'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span><span class="o">+</span><span class="s">'.jpg'</span><span class="p">)</span>

        <span class="n">im1</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">image1_path</span><span class="p">)</span>
        <span class="n">im2</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">image2_path</span><span class="p">)</span>
        <span class="n">im3</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">image3_path</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">data_path</span><span class="p">)</span>
        <span class="n">pts1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'pts1'</span><span class="p">]</span>
        <span class="n">pts2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'pts2'</span><span class="p">]</span>
        <span class="n">pts3</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'pts3'</span><span class="p">]</span>

        <span class="n">K1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'K1'</span><span class="p">]</span>
        <span class="n">K2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'K2'</span><span class="p">]</span>
        <span class="n">K3</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'K3'</span><span class="p">]</span>

        <span class="n">M1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'M1'</span><span class="p">]</span>
        <span class="n">M2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'M2'</span><span class="p">]</span>
        <span class="n">M3</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'M3'</span><span class="p">]</span>

        <span class="c1">#Note - Press 'Escape' key to exit img preview and loop further 
</span>        <span class="c1"># img = visualize_keypoints(im2, pts2)
</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">K1</span> <span class="o">@</span> <span class="n">M1</span>
        <span class="n">C2</span> <span class="o">=</span> <span class="n">K2</span> <span class="o">@</span> <span class="n">M2</span>
        <span class="n">C3</span> <span class="o">=</span> <span class="n">K3</span> <span class="o">@</span> <span class="n">M3</span>
        <span class="n">pts_3d</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">vis_pts_list</span> <span class="o">=</span> <span class="n">MultiviewReconstruction</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">pts2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">pts3</span><span class="p">)</span>
        <span class="n">x_start</span> <span class="o">=</span> <span class="n">pts_3d</span><span class="p">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="n">x_optimized_obj</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">MutliviewReconstructionError</span><span class="p">,</span> <span class="n">x_start</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">pts2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">pts3</span><span class="p">,</span> <span class="n">vis_pts_list</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s">'Powell'</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"x_end shape is"</span><span class="p">,</span> <span class="n">x_optimized_obj</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">x_optimized</span> <span class="o">=</span> <span class="n">x_optimized_obj</span><span class="p">.</span><span class="n">x</span>

        <span class="n">P_final</span> <span class="o">=</span> <span class="n">x_optimized</span>
        <span class="n">P_shape_req</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">P_final</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">P_final</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">P_final</span><span class="p">,</span> <span class="n">newshape</span><span class="o">=</span><span class="p">(</span><span class="n">P_shape_req</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">plot_3d_keypoint</span><span class="p">(</span><span class="n">P_final</span><span class="p">)</span>
        <span class="n">pts_3d_video</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">P_final</span><span class="p">)</span>
        <span class="n">visualize_keypoints</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">pts1</span><span class="p">,</span> <span class="n">Threshold</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    
    <span class="n">plot_3d_keypoint_video</span><span class="p">(</span><span class="n">pts_3d_video</span><span class="p">)</span>
    <span class="n">out_dir</span> <span class="o">=</span> <span class="s">"/home/sush/CMU/Assignment_Sem_1/CV_A/Assignment_4/code/outputs"</span>
    <span class="n">check_and_create_directory</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">np</span><span class="p">.</span><span class="n">savez_compressed</span><span class="p">(</span>
                        <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="s">'q6_1.npz'</span><span class="p">),</span>
                        <span class="n">P_final</span><span class="p">)</span>
</code></pre></div></div>

          

          
            
          
        </main>
        

  <hr>
  <footer>
    

    <p class="text-small text-grey-dk-100 mb-0"></p>

    
      <div class="d-flex mt-2">
        
        
      </div>
    
  </footer>


      </div>
    </div>
    
      

<div class="search-overlay"></div>

    
  </div>

  
</body>
</html>

