

<!DOCTYPE html>

<html lang="en-US">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">

  

  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

  <link rel="stylesheet" href="/assets/css/just-the-docs-default.css">

  

  
    <script type="text/javascript" src="/assets/js/vendor/lunr.min.js"></script>
  
  <script type="text/javascript" src="/assets/js/just-the-docs.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Planar Homography | My Projects</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Planar Homography" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Computer Vision projects and assignments during my time in CMU" />
<meta property="og:description" content="Computer Vision projects and assignments during my time in CMU" />
<link rel="canonical" href="http://localhost:4000/planar_homography/" />
<meta property="og:url" content="http://localhost:4000/planar_homography/" />
<meta property="og:site_name" content="My Projects" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Planar Homography" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Computer Vision projects and assignments during my time in CMU","headline":"Planar Homography","url":"http://localhost:4000/planar_homography/"}</script>
<!-- End Jekyll SEO tag -->


  

</head>

<body>
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
    <symbol id="svg-link" viewBox="0 0 24 24">
      <title>Link</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link">
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
      </svg>
    </symbol>
    <symbol id="svg-search" viewBox="0 0 24 24">
      <title>Search</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search">
        <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
    </symbol>
    <symbol id="svg-menu" viewBox="0 0 24 24">
      <title>Menu</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu">
        <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </symbol>
    <symbol id="svg-arrow-right" viewBox="0 0 24 24">
      <title>Expand</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
    </symbol>
    <symbol id="svg-doc" viewBox="0 0 24 24">
      <title>Document</title>
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file">
        <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>
      </svg>
    </symbol>
  </svg>

  <div class="side-bar">
    <div class="site-header">
      <a href="http://localhost:4000/" class="site-title lh-tight">
  My Projects

</a>
      <a href="#" id="menu-button" class="site-button">
        <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg>
      </a>
    </div>
    <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav">
      
        <ul class="nav-list"><li class="nav-list-item"><a href="http://localhost:4000/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="http://localhost:4000/intro/" class="nav-list-link">Building this Page</a></li><li class="nav-list-item active"><a href="http://localhost:4000/planar_homography/" class="nav-list-link active">Planar Homography</a></li><li class="nav-list-item"><a href="http://localhost:4000/3D_reconstruction/" class="nav-list-link">3D_reconstruction</a></li><li class="nav-list-item"><a href="http://localhost:4000/optical_flow/" class="nav-list-link">Optical Flow and Image Alignment</a></li><li class="nav-list-item"><a href="http://localhost:4000/constr_rrt/" class="nav-list-link">Constrained RRT</a></li><li class="nav-list-item"><a href="http://localhost:4000/spatial_pyramid_matching/" class="nav-list-link">Spatial Pyramid Matching for Scene Classification</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/DL_overview" class="nav-list-link">DL Overview</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/DL.html" class="nav-list-link">Deep Learning Starter</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/DL_old_arches.html" class="nav-list-link">DL Simple Architechtures</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/IDL1.html" class="nav-list-link">MLPs (IDL1)</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/IDL2.html" class="nav-list-link">Classifiers (IDL2)</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/IDL3.html" class="nav-list-link">Optimizers and Regularizers (IDL3)</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/IDL4.html" class="nav-list-link">Intro to CNNs</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/DL_Overview/Resnet.html" class="nav-list-link">RESNET</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/Intro%20to%20ML" class="nav-list-link">Intro to ML</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/Intro%20to%20ML/Basics.html" class="nav-list-link">Basics</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/Intro%20to%20ML/Linear_Regression.html" class="nav-list-link">Linear Regression</a></li></ul></li><li class="nav-list-item"><a href="http://localhost:4000/pytorch/" class="nav-list-link">Intro to Pytorch</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/SLAM" class="nav-list-link">SLAM</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Probability_review.html" class="nav-list-link">Recap on Probability</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Expectation_and_cov.html" class="nav-list-link">Expectation and Covariance</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Particle%20Filter_theory.html" class="nav-list-link">Particle Filters Theory</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/EKF.html" class="nav-list-link">EKF</a></li><li class="nav-list-item "><a href="http://localhost:4000/docs/SLAM/Non_linear_slam.html" class="nav-list-link">Least Squares SLAM</a></li></ul></li><li class="nav-list-item"><a href="http://localhost:4000/mrsd_proj/" class="nav-list-link">MRSD Capstone Project</a></li><li class="nav-list-item"><a href="http://localhost:4000/camera_model/" class="nav-list-link">Camera Models</a></li><li class="nav-list-item"><a href="http://localhost:4000/numpy/" class="nav-list-link">Numpy</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/docs/Vision%20with%20C++" class="nav-list-link">Computer Vision using C++</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/docs/Vision%20with%20C++/Eigen.html" class="nav-list-link">Linear Algebra in Eigen</a></li></ul></li></ul>

      
    </nav>
    <footer class="site-footer">
      This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.
    </footer>
  </div>
  <div class="main" id="top">
    <div id="main-header" class="main-header">
      
        <div class="search">
          <div class="search-input-wrap">
            <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search My Projects" aria-label="Search My Projects" autocomplete="off">
            <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label>
          </div>
          <div id="search-results" class="search-results"></div>
        </div>
      
      
      
        <nav aria-label="Auxiliary" class="aux-nav">
          <ul class="aux-nav-list">
            
              <li class="aux-nav-list-item">
                <a href="//github.com/sushanthj" class="site-button"
                  
                >
                  Sushanth Jayanth's github
                </a>
              </li>
            
          </ul>
        </nav>
      
    </div>
    <div id="main-content-wrap" class="main-content-wrap">
      
        
      
      <div id="main-content" class="main-content" role="main">
        
          <p><img src="/images/mp4ar_video_AdobeExpress.gif" alt="" /></p>

<details open="">
  <summary class="text-delta">
    Table of contents
  </summary>
<ol id="markdown-toc">
  <li><a href="#before-you-begin" id="markdown-toc-before-you-begin">Before you Begin</a></li>
  <li><a href="#pdfs" id="markdown-toc-pdfs">PDFs</a></li>
  <li><a href="#some-basics-on-camera-projection" id="markdown-toc-some-basics-on-camera-projection">Some Basics on Camera Projection</a>    <ol>
      <li><a href="#projection-of-3d-to-2d-image-plane" id="markdown-toc-projection-of-3d-to-2d-image-plane">Projection of 3D to 2D image plane</a></li>
      <li><a href="#camera-matrices" id="markdown-toc-camera-matrices">Camera Matrices</a>        <ol>
          <li><a href="#generic-representation" id="markdown-toc-generic-representation">Generic Representation</a></li>
          <li><a href="#alternate-notation-of-camera-matrices" id="markdown-toc-alternate-notation-of-camera-matrices">Alternate notation of camera matrices</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#the-homography-situation" id="markdown-toc-the-homography-situation">The Homography Situation</a>    <ol>
      <li><a href="#single-view" id="markdown-toc-single-view">Single View</a></li>
      <li><a href="#multiple-views" id="markdown-toc-multiple-views">Multiple Views</a></li>
      <li><a href="#limitations-of-planar-homography" id="markdown-toc-limitations-of-planar-homography">Limitations of Planar Homography</a></li>
    </ol>
  </li>
  <li><a href="#implementation-of-homography-estimation" id="markdown-toc-implementation-of-homography-estimation">Implementation of Homography Estimation</a>    <ol>
      <li><a href="#the-pipeline" id="markdown-toc-the-pipeline">The Pipeline</a>        <ol>
          <li><a href="#keypoint-detection" id="markdown-toc-keypoint-detection">Keypoint Detection</a></li>
          <li><a href="#keypoint-descriptors" id="markdown-toc-keypoint-descriptors">Keypoint Descriptors</a></li>
          <li><a href="#calculating-the-homography-matrix" id="markdown-toc-calculating-the-homography-matrix">Calculating the Homography Matrix</a></li>
          <li><a href="#bonus-ransac-rejecting-outliers-during-our-homography-calculation" id="markdown-toc-bonus-ransac-rejecting-outliers-during-our-homography-calculation">(Bonus) RANSAC: Rejecting outliers during our homography calculation</a></li>
          <li><a href="#implementation-of-above-steps" id="markdown-toc-implementation-of-above-steps">Implementation of above steps</a></li>
          <li><a href="#ransac-and-construction-of-composite-image" id="markdown-toc-ransac-and-construction-of-composite-image">RANSAC and Construction of Composite Image</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#applying-homography-estimation-in-the-real-world" id="markdown-toc-applying-homography-estimation-in-the-real-world">Applying Homography Estimation in the Real World</a>    <ol>
      <li><a href="#basic-cool-applications" id="markdown-toc-basic-cool-applications">Basic cool applications</a></li>
      <li><a href="#ar-video" id="markdown-toc-ar-video">AR Video</a></li>
      <li><a href="#panorama-stitching" id="markdown-toc-panorama-stitching">Panorama Stitching</a></li>
    </ol>
  </li>
  <li><a href="#acknowledgement-and-references" id="markdown-toc-acknowledgement-and-references">Acknowledgement and References</a>    <ol>
      <li><a href="#my-ohiopyle-trip" id="markdown-toc-my-ohiopyle-trip">My Ohiopyle trip</a></li>
    </ol>
  </li>
  <li><a href="#helper-functions" id="markdown-toc-helper-functions">Helper Functions</a></li>
</ol>

</details>
      <h2 id="before-you-begin">
        
        
          <a href="#before-you-begin" class="anchor-heading" aria-labelledby="before-you-begin"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Before you Begin
        
        
      </h2>
    

<p><a href="https://drive.google.com/file/d/1jqEB739EfifhSyiCK6vdbPIz7gX9Ywmr/view?usp=sharing" class="btn fs-3 mb-4 mb-md-0">Reference Book 1</a>
<a href="https://drive.google.com/file/d/1Kn6dilDeR_7leIctuVa87-czuqBoxJh-/view?usp=sharing" class="btn fs-3 mb-4 mb-md-0">Reference Book 2</a></p>
      <h2 id="pdfs">
        
        
          <a href="#pdfs" class="anchor-heading" aria-labelledby="pdfs"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> PDFs
        
        
      </h2>
    

<p><a href="https://github.com/sushanthj/assignments_F22/blob/main/CV_A/Assignment_3/hw3_f22.pdf" class="btn fs-3 mb-4 mb-md-0">Assignment Questionnaire</a></p>

<p><a href="https://github.com/sushanthj/assignments_F22/blob/main/CV_A/Assignment_3/sushantj_hw3.pdf" class="btn fs-3 mb-4 mb-md-0">My Answers</a></p>
      <h1 id="some-basics-on-camera-projection">
        
        
          <a href="#some-basics-on-camera-projection" class="anchor-heading" aria-labelledby="some-basics-on-camera-projection"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Some Basics on Camera Projection
        
        
      </h1>
    
      <h2 id="projection-of-3d-to-2d-image-plane">
        
        
          <a href="#projection-of-3d-to-2d-image-plane" class="anchor-heading" aria-labelledby="projection-of-3d-to-2d-image-plane"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Projection of 3D to 2D image plane
        
        
      </h2>
    

<p>To understand how a camera views the 3D world, first we look at the projection of 
3D points onto an image plane. We use basic high school physics and some similar triangle properties
to derive the following formula:</p>

<p><img src="/images/homography/0.png" alt="" /></p>

<p>Notice that the minus sign is bit irritating to work with. (Also we don’t see inverted images
as the formula suggests. This is becauase our brain does the inversion in real time)</p>

<p>Therefore, let’s start with the below version of the formula by ignoring this inversion effect</p>

<p><img src="/images/homography/1.png" alt="" /></p>

<p>Now, the above equation can be written in matrix form, 
<strong>but we’ll form one artifact in this conversion i.e. lambda</strong></p>

<p><img src="/images/homography/2.png" alt="" /></p>

<p>It’s clear that we can find this lambda as shown. However, why do we even need this? <br />
Ans. We want to represent the coordinates in <strong>homogenous coordinates</strong></p>

<p><img src="/images/homography/4.png" alt="" /></p>

<p><img src="/images/homography/3.png" alt="" /></p>
      <h2 id="camera-matrices">
        
        
          <a href="#camera-matrices" class="anchor-heading" aria-labelledby="camera-matrices"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Camera Matrices
        
        
      </h2>
    
      <h3 id="generic-representation">
        
        
          <a href="#generic-representation" class="anchor-heading" aria-labelledby="generic-representation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Generic Representation
        
        
      </h3>
    

<p>Now, let’s add another constraint on this equation. Suppose we rotate our 3D point in space or we
rotate the camera itself by a certain angle. In the world of robotics we call such transforms as a 
rotation matrix.</p>

<p><a href="https://en.wikipedia.org/wiki/Rotation_matrix">Reference: Rotation Matrices</a></p>

<p>To get a good grasp of rotation matrices, I highly recommend some linear algebra brush-up using 3B1B
(3 Blue 1 Brown). Specifically <a href="https://www.youtube.com/watch?v=kYB8IZa5AuE&amp;list=PL0-GT3co4r2y2YErbmuJw2L5tW4Ew2O5B&amp;index=4&amp;ab_channel=3Blue1Brown">(watch 8th minute of this video)</a>
The rotation shown in the above video in the 8th minute <strong>is a rotation matrix in 2D</strong>.</p>

<p>Now, adding a <strong>3D translation</strong> (just 3 numbers which add to the x,y,z component of a 3D vector) 
along with a <strong>3D rotation</strong> we get the <strong>basic projection equation</strong></p>

<p><img src="/images/homography/5.png" alt="" /></p>

<p><em>Where the two matrices are called the camera intrinsics (captures focal lengths) and the 
camera extrinsics (capturing rotation and translation)</em></p>

<p>This rotation (r-matrix) can also be visualized as fixing a world coordinate frame onto some 
plane in the 3D world (think of a it as a flat table top) and then thinking 
how our camera is rotated w.r.t that frame:</p>

<p><img src="/images/homography/10.png" alt="" /></p>

<p>Now, most cameras also distort images due to lens optics or other properties inherent in building
the camera itself. These are captured as shown below:</p>

<p><img src="/images/homography/8.png" alt="" /></p>

<p>Now, adding these intrinsic and extrinsic factors, we get:</p>

<p><img src="/images/homography/9.png" alt="" /></p>
      <h3 id="alternate-notation-of-camera-matrices">
        
        
          <a href="#alternate-notation-of-camera-matrices" class="anchor-heading" aria-labelledby="alternate-notation-of-camera-matrices"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Alternate notation of camera matrices
        
        
      </h3>
    

<p><img src="/images/homography/6.png" alt="" /></p>
      <h1 id="the-homography-situation">
        
        
          <a href="#the-homography-situation" class="anchor-heading" aria-labelledby="the-homography-situation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Homography Situation
        
        
      </h1>
    
      <h2 id="single-view">
        
        
          <a href="#single-view" class="anchor-heading" aria-labelledby="single-view"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Single View
        
        
      </h2>
    

<p>Now, if we focus on only planes (table top and human holding camera situation): <br />
We can make certain simplifying assumptions. This is primarily that the 3D point we’re looking at
has constant depth in it’s immediate neighbourhood. Using this we simplify our equations to:</p>

<p><img src="/images/homography/11.png" alt="" /></p>

<p><strong>This 3x3 m-matrix now represents the mapping of 3D points on a plane to 2D point in an image</strong></p>
      <h2 id="multiple-views">
        
        
          <a href="#multiple-views" class="anchor-heading" aria-labelledby="multiple-views"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Multiple Views
        
        
      </h2>
    

<p>Now, by simple extension of the above logic we can derive the following:</p>
<ul>
  <li>We have just 1 plane in the 3D world</li>
  <li>We have two cameras looking at this plane</li>
  <li>Each camera has it’s own 3x3 m-matrix which maps 3D plane points onto 2D image frame</li>
  <li>Therefore if two cameras can see the same 3D point, we can find a mapping between the two cameras</li>
  <li>This mapping between the two cameras is given by a new 3x3 matrix called the homography matrix</li>
</ul>

<p><img src="/images/homography/12.png" alt="" /></p>

<p><img src="/images/homography/13.png" alt="" /></p>
      <h2 id="limitations-of-planar-homography">
        
        
          <a href="#limitations-of-planar-homography" class="anchor-heading" aria-labelledby="limitations-of-planar-homography"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Limitations of Planar Homography
        
        
      </h2>
    

<ol>
  <li>
    <p>When the scene is very far away from the camera, all objects can be said to have the same depth.
This is because the relative depth distances between foreground and background will be negligible in
comparison to the average scene depth. Therefore, in such cases all objects in scene can be said
to lie on a plane and as proved above, can be captured by two cameras related by a homography
matrix.</p>
  </li>
  <li>
    <p>For nearby scenes where the variation in scene depth is more apparent, a homography mapping works
well only under pure rotation.</p>
  </li>
</ol><hr />
      <h1 id="implementation-of-homography-estimation">
        
        
          <a href="#implementation-of-homography-estimation" class="anchor-heading" aria-labelledby="implementation-of-homography-estimation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Implementation of Homography Estimation
        
        
      </h1>
    
      <h2 id="the-pipeline">
        
        
          <a href="#the-pipeline" class="anchor-heading" aria-labelledby="the-pipeline"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Pipeline
        
        
      </h2>
    

<p>The main application of homography transforms is to find how some reference template has been warped
due to movement of the camera. This is seem below as:</p>

<p><img src="/images/homography/15.png" alt="" /></p>

<p>The applications of this are:</p>
<ul>
  <li>image stitching (think of two images from two views as a warped version of view 0)</li>
  <li>augmented reality (projecting some images onto a fixed/known plane in the real world)</li>
</ul>

<p>To perform any of the above cool applications, we first need to compute the homography between any
two views. The pipeline for this would be:</p>

<ol>
  <li><strong>Have one reference view and another view</strong> with the camera having moved slightly</li>
  <li><strong>Detect some keypoints</strong> (interest points like corners/edges) in each image</li>
  <li><strong>Describe these keypoints</strong> in some way (maybe capture the histogram of pixel intensities 
in a small patch around the keypoint)</li>
  <li><strong>Match the keypoints</strong> in one image to another using the keypoint descriptions</li>
  <li>Use the spatial information of these matched keypoints (i.e. the x,y coordinates of 
each of these keypoints) to <strong>find the Homography matrix</strong></li>
  <li>**Apply the homography matrix as a transformation on one of the images **to warp 
and match the images</li>
</ol>

<p>Let’s go deeper into the each of the above steps:</p>
      <h3 id="keypoint-detection">
        
        
          <a href="#keypoint-detection" class="anchor-heading" aria-labelledby="keypoint-detection"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Keypoint Detection
        
        
      </h3>
    

<ul>
  <li>There are several methods to find keypoints in an image. Usually these keypoints are corners
since other features like edges may warp or curve due to distortion and may be difficult to trace.</li>
  <li>The common methods are Harris Corner Detector, polygon fitting, FAST detectors etc.</li>
  <li><strong>Here we use the FAST detector</strong></li>
</ul>

<p><img src="/images/homography/16.png" alt="" /></p>
      <h3 id="keypoint-descriptors">
        
        
          <a href="#keypoint-descriptors" class="anchor-heading" aria-labelledby="keypoint-descriptors"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Keypoint Descriptors
        
        
      </h3>
    

<p>Common descriptors include BRIEF, ORB, SIFT etc. <strong>Here we’ve used the BRIEF descriptor</strong></p>

<p><img src="/images/homography/18.png" alt="" /></p>

<p>The BRIEF descriptor works by creating a binary feature vector of a patch from random
(x,y) point pairs. This randomness in generating point pairs ensures changes in pixel
intensities are captuerd in multiple directions thereby being sensitive to a large variety of
edges or corners. The BRIEF descriptor also compares these binary strings using hamming distance
further reduces compute time.</p>

<p>Due to this computational cost of calculating histograms for each filter bank it 
would not make sense to use filterbanks instead of BRIEF. <br />
Further, just filterbanks cannot encode patch descriptions, i.e. without any
form of histograms (like SIFT), the filterbanks themselves cannot be used instead of BRIEF.</p>

<p><a href="https://medium.com/data-breach/introduction-to-brief-binary-robust-independent-elementary-features-436f4a31a0e6">Reference: BRIEF Descriptor</a></p>

<p>The implementation of keypoint detection, description and matching are shown below:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">skimage.color</span>
<span class="kn">from</span> <span class="nn">helper</span> <span class="kn">import</span> <span class="n">briefMatch</span>
<span class="kn">from</span> <span class="nn">helper</span> <span class="kn">import</span> <span class="n">computeBrief</span>
<span class="kn">from</span> <span class="nn">helper</span> <span class="kn">import</span> <span class="n">corner_detection</span>

<span class="c1"># Q2.1.4
</span>
<span class="k">def</span> <span class="nf">matchPics</span><span class="p">(</span><span class="n">I1</span><span class="p">,</span> <span class="n">I2</span><span class="p">,</span> <span class="n">opts</span><span class="p">):</span>
        <span class="s">"""
        Match features across images

        Input
        -----
        I1, I2: Source images
        opts: Command line args

        Returns
        -------
        matches: List of indices of matched features across I1, I2 [p x 2]
        locs1, locs2: Pixel coordinates of matches [N x 2]
        """</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"computing image matches"</span><span class="p">)</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="n">ratio</span>  <span class="c1">#'ratio for BRIEF feature descriptor'
</span>        <span class="n">sigma</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="n">sigma</span>  <span class="c1">#'threshold for corner detection using FAST feature detector'
</span>        

        <span class="c1"># Convert Images to GrayScale
</span>        <span class="n">I1</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">I1</span><span class="p">)</span>
        <span class="n">I2</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">I2</span><span class="p">)</span>
        
        <span class="c1"># Detect Features in Both Images
</span>        <span class="c1"># locs1 is just the detected corners of I1
</span>        <span class="n">locs1</span> <span class="o">=</span> <span class="n">corner_detection</span><span class="p">(</span><span class="n">I1</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="n">locs2</span> <span class="o">=</span> <span class="n">corner_detection</span><span class="p">(</span><span class="n">I2</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
        
        <span class="c1"># Obtain descriptors for the computed feature locations
</span>        <span class="c1"># We use the breif descriptor to give the patch descriptions (patch of pixel width = 9)
</span>        <span class="c1"># for the corners(keypoints) which we obtained from corner_description
</span>
        <span class="c1"># desc is the binary string (len(string)=256 and 256bits)
</span>        <span class="c1"># which serves as the feature descriptor
</span>        <span class="n">desc1</span><span class="p">,</span> <span class="n">locs1</span> <span class="o">=</span> <span class="n">computeBrief</span><span class="p">(</span><span class="n">I1</span><span class="p">,</span> <span class="n">locs1</span><span class="p">)</span>
        <span class="n">desc2</span><span class="p">,</span> <span class="n">locs2</span> <span class="o">=</span> <span class="n">computeBrief</span><span class="p">(</span><span class="n">I2</span><span class="p">,</span> <span class="n">locs2</span><span class="p">)</span>

        <span class="c1"># Match features using the descriptors
</span>        <span class="n">matches</span> <span class="o">=</span> <span class="n">briefMatch</span><span class="p">(</span><span class="n">desc1</span><span class="p">,</span> <span class="n">desc2</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Computed </span><span class="si">{</span><span class="n">matches</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> matches successfully'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">matches</span><span class="p">,</span> <span class="n">locs1</span><span class="p">,</span> <span class="n">locs2</span>

<span class="k">def</span> <span class="nf">briefMatch</span><span class="p">(</span><span class="n">desc1</span><span class="p">,</span><span class="n">desc2</span><span class="p">,</span><span class="n">ratio</span><span class="p">):</span>

    <span class="n">matches</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">feature</span><span class="p">.</span><span class="n">match_descriptors</span><span class="p">(</span><span class="n">desc1</span><span class="p">,</span><span class="n">desc2</span><span class="p">,</span><span class="s">'hamming'</span><span class="p">,</span><span class="n">cross_check</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">max_ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">matches</span>
</code></pre></div></div>
      <h3 id="calculating-the-homography-matrix">
        
        
          <a href="#calculating-the-homography-matrix" class="anchor-heading" aria-labelledby="calculating-the-homography-matrix"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Calculating the Homography Matrix
        
        
      </h3>
    

<p>Let’s say we have two images: <strong>image1 and image2</strong></p>

<p><img src="/images/homography/19.png" alt="" /></p>

<p>To Derive the A matrix we undergo the following steps:</p>

<p><img src="/images/homography/20.png" alt="" /></p>

<p><img src="/images/homography/21.png" alt="" /></p>

<ul>
  <li>Where h is found by taking the SVD of A and choosing the eigen vector (with least eigen value)
which forms the null space of A.</li>
  <li>Remember, null-space of a vector is the transformation (i.e. transformation matrix) which
squeezed the vector onto a point (i.e. it reduces dimensions to zero).</li>
  <li>In this case <strong>x</strong> is the vector and we find the corresponding transformation matrix which
forms it’s null-space. This matrix then becomes our homography matrix</li>
  <li>For a better understanding of SVD, refer to <a href="https://drive.google.com/file/d/1d6xcBbI2qcyaCx-rccI3sc9pdjQFMp2n/view?usp=sharing">This Document</a></li>
</ul>
      <h3 id="bonus-ransac-rejecting-outliers-during-our-homography-calculation">
        
        
          <a href="#bonus-ransac-rejecting-outliers-during-our-homography-calculation" class="anchor-heading" aria-labelledby="bonus-ransac-rejecting-outliers-during-our-homography-calculation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> (Bonus) RANSAC: Rejecting outliers during our homography calculation
        
        
      </h3>
    

<p><img src="/images/homography/24.png" alt="" /></p>
      <h3 id="implementation-of-above-steps">
        
        
          <a href="#implementation-of-above-steps" class="anchor-heading" aria-labelledby="implementation-of-above-steps"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Implementation of above steps
        
        
      </h3>
    

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">skimage.io</span> 
<span class="kn">import</span> <span class="nn">skimage.color</span>
<span class="kn">from</span> <span class="nn">planarH</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">opts</span> <span class="kn">import</span> <span class="n">get_opts</span>
<span class="kn">from</span> <span class="nn">matchPics</span> <span class="kn">import</span> <span class="n">matchPics</span>
<span class="kn">from</span> <span class="nn">helper</span> <span class="kn">import</span> <span class="n">briefMatch</span>

<span class="k">def</span> <span class="nf">warpImage</span><span class="p">(</span><span class="n">opts</span><span class="p">):</span>
    <span class="s">"""
    Warp template image based on homography transform
    Args:
        opts: user inputs
    """</span>
    <span class="n">image1</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'../data/cv_cover.jpg'</span><span class="p">)</span>
    <span class="n">image2</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'../data/cv_desk.png'</span><span class="p">)</span>
    <span class="n">template_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'../data/hp_cover.jpg'</span><span class="p">)</span>

    <span class="c1"># make sure harry_potter image is same size as CV book
</span>    <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">image1</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">template_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">template_img</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">))</span>

    <span class="n">matches</span><span class="p">,</span> <span class="n">locs1</span><span class="p">,</span> <span class="n">locs2</span> <span class="o">=</span> <span class="n">matchPics</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>

    <span class="c1"># invert the columns of locs1 and locs2
</span>    <span class="n">locs1</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">locs1</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="n">locs2</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">locs2</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>

    <span class="n">matched_points</span> <span class="o">=</span> <span class="n">create_matched_points</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">locs1</span><span class="p">,</span> <span class="n">locs2</span><span class="p">)</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">inlier</span> <span class="o">=</span> <span class="n">computeH_ransac</span><span class="p">(</span><span class="n">matched_points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">matched_points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:],</span> <span class="n">opts</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"homography matrix is </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    
    <span class="c1"># compositeH(h, source, destination)
</span>    <span class="n">composite_img</span> <span class="o">=</span> <span class="n">compositeH</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">template_img</span><span class="p">,</span> <span class="n">image2</span><span class="p">)</span>

    <span class="c1"># Display images
</span>    <span class="n">cv2</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">"Composite Image :)"</span><span class="p">,</span> <span class="n">composite_img</span><span class="p">)</span>
    <span class="n">cv2</span><span class="p">.</span><span class="n">waitKey</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>

    <span class="n">opts</span> <span class="o">=</span> <span class="n">get_opts</span><span class="p">()</span>
    <span class="n">warpImage</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
</code></pre></div></div>
      <h3 id="ransac-and-construction-of-composite-image">
        
        
          <a href="#ransac-and-construction-of-composite-image" class="anchor-heading" aria-labelledby="ransac-and-construction-of-composite-image"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> RANSAC and Construction of Composite Image
        
        
      </h3>
    
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">replace</span>
<span class="kn">from</span> <span class="nn">platform</span> <span class="kn">import</span> <span class="n">python_branch</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">skimage.color</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>
<span class="kn">from</span> <span class="nn">matchPics</span> <span class="kn">import</span> <span class="n">matchPics</span>
<span class="kn">from</span> <span class="nn">helper</span> <span class="kn">import</span> <span class="n">plotMatches</span>
<span class="kn">from</span> <span class="nn">opts</span> <span class="kn">import</span> <span class="n">get_opts</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>


<span class="k">def</span> <span class="nf">computeH</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
    <span class="s">"""
    Computes the homography based on 
    matching points in both images

    Args:
        x1: keypoints in image 1
        x2: keypoints in image 2

    Returns:
        H2to1: the homography matrix
    """</span>

    <span class="c1"># Define a dummy H matrix
</span>    <span class="n">A_build</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Define the A matrix for (Ah = 0) (A matrix size = N*2 x 9)
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">row_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">])</span>
        <span class="n">row_2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">])</span>
        <span class="n">A_build</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_1</span><span class="p">)</span>
        <span class="n">A_build</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_2</span><span class="p">)</span>
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">stack</span><span class="p">(</span><span class="n">A_build</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Do the least squares minimization to get the homography matrix
</span>    <span class="c1"># this is done as eigenvector coresponding to smallest eigen value of A`A = H matrix
</span>    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">svd</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="p">))</span>

    <span class="c1"># here the linalg.svd gives v_transpose
</span>    <span class="c1"># but we need just V therefore we again transpose
</span>    <span class="n">H2to1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">T</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">H2to1</span>


<span class="k">def</span> <span class="nf">computeH_norm</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
    <span class="c1">#Q2.2.2
</span>    <span class="s">"""
    Compute the normalized coordinates
    and also the homography matrix using computeH

    Args:
        x1 (Mx2): the matched locations of corners in img1
        x2 (Mx2): the matched locations of corners in img2

    Returns:
        H2to1: Hmography matrix after denormalization
    """</span>
    <span class="c1"># Q2.2.2
</span>    <span class="c1"># Compute the centroid of the points
</span>    <span class="n">centroid_img_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">x1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">centroid_img_2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">x2</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># print(f'centroid of img1 is {centroid_img_1} \n centroid of img2 is {centroid_img_2}')
</span>
    <span class="c1"># Shift the origin of the points to the centroid
</span>    <span class="c1"># let origin for img1 be centroid_img_1 and similarly for img2
</span>    <span class="c1">#? Now translate every point such that centroid is at [0,0]
</span>    <span class="n">moved_x1</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">centroid_img_1</span>
    <span class="n">moved_x2</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">centroid_img_2</span>

    <span class="n">current_max_dist_img1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">moved_x1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">current_max_dist_img2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">moved_x2</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    
    <span class="c1"># moved and scaled image 1 points
</span>    <span class="n">scale1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">current_max_dist_img1</span><span class="p">)</span>
    <span class="n">scale2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">current_max_dist_img2</span><span class="p">)</span>
    <span class="n">moved_scaled_x1</span> <span class="o">=</span> <span class="n">moved_x1</span> <span class="o">*</span> <span class="n">scale1</span>
    <span class="n">moved_scaled_x2</span> <span class="o">=</span> <span class="n">moved_x2</span> <span class="o">*</span> <span class="n">scale2</span>

    <span class="c1"># Similarity transform 1
</span>    <span class="c1">#? We construct the transformation matrix to be 3x3 as it has to be same shape of Homography
</span>    <span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">([</span><span class="n">scale1</span><span class="p">,</span> <span class="n">scale1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">t1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">scale1</span><span class="o">*</span><span class="n">centroid_img_1</span>

    <span class="c1"># Similarity transform 2
</span>    <span class="n">t2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">([</span><span class="n">scale2</span><span class="p">,</span> <span class="n">scale2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">t2</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">scale2</span><span class="o">*</span><span class="n">centroid_img_2</span>

    <span class="c1"># Compute homography
</span>    <span class="n">H</span> <span class="o">=</span> <span class="n">computeH</span><span class="p">(</span><span class="n">moved_scaled_x1</span><span class="p">,</span> <span class="n">moved_scaled_x2</span><span class="p">)</span>

    <span class="c1"># Denormalization
</span>    <span class="n">H2to1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">inv</span><span class="p">(</span><span class="n">t1</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">t2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">H2to1</span>

<span class="k">def</span> <span class="nf">create_matched_points</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">locs1</span><span class="p">,</span> <span class="n">locs2</span><span class="p">):</span>
    <span class="s">"""
    Match the corners in img1 and img2 according to the BRIEF matched points

    Args:
        matches (Mx2): Vector containing the index of locs1 and locs2 which matches
        locs1 (Nx2): Vector containing corner positions for img1
        locs2 (Nx2):  Vector containing corner positions for img2

    Returns:
        _type_: _description_
    """</span>
    <span class="n">matched_pts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">matches</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">matched_pts</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">locs1</span><span class="p">[</span><span class="n">matches</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="n">locs1</span><span class="p">[</span><span class="n">matches</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">],</span>
                                              <span class="n">locs2</span><span class="p">[</span><span class="n">matches</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="n">locs2</span><span class="p">[</span><span class="n">matches</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">]]))</span>
    
    <span class="c1"># remove the first dummy value and return
</span>    <span class="n">matched_points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">stack</span><span class="p">(</span><span class="n">matched_pts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">matched_points</span>

<span class="k">def</span> <span class="nf">computeH_ransac</span><span class="p">(</span><span class="n">locs1</span><span class="p">,</span> <span class="n">locs2</span><span class="p">,</span> <span class="n">opts</span><span class="p">):</span>
    <span class="s">"""
    Every iteration we init a Homography matrix using 4 corresponding
    points and calculate number of inliers. Finally use the Homography
    matrix which had max number of inliers (and these inliers as well)
    to find the final Homography matrix
    Args:
        locs1: location of matched points in image1
        locs2: location of matched points in image2
        opts: user inputs used for distance tolerance in ransac

    Returns:
        bestH2to1     : The homography matrix with max number of inliers
        final_inliers : Final list of inliers considered for homography
    """</span>
    <span class="c1">#Q2.2.3
</span>    <span class="c1">#Compute the best fitting homography given a list of matching points
</span>    
    <span class="n">max_iters</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="n">max_iters</span>  <span class="c1"># the number of iterations to run RANSAC for
</span>    <span class="n">inlier_tol</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="n">inlier_tol</span> <span class="c1"># the tolerance value for considering a point to be an inlier
</span>
    <span class="c1"># define size of both locs1 and locs2
</span>    <span class="n">num_rows</span> <span class="o">=</span> <span class="n">locs1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># define a container for keeping track of inlier counts
</span>    <span class="n">final_inlier_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">final_distance_error</span> <span class="o">=</span> <span class="mi">10000</span>

    <span class="c1">#? Create a boolean vector of length N where 1 = inlier and 0 = outlier
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Computing RANSAC"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iters</span><span class="p">):</span>
        <span class="n">test_locs1</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">locs1</span><span class="p">)</span>
        <span class="n">test_locs2</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">locs2</span><span class="p">)</span>
        <span class="c1"># chose a random sample of 4 points to find H
</span>        <span class="n">rand_index</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">rand_index</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">locs1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        
        <span class="n">rand_points_1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rand_points_2</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">rand_index</span><span class="p">:</span>
            <span class="n">rand_points_1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">locs1</span><span class="p">[</span><span class="n">j</span><span class="p">,:])</span>
            <span class="n">rand_points_2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">locs2</span><span class="p">[</span><span class="n">j</span><span class="p">,:])</span>
        
        <span class="n">test_locs1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">test_locs1</span><span class="p">,</span> <span class="n">rand_index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">test_locs2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">test_locs2</span><span class="p">,</span> <span class="n">rand_index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
        <span class="n">correspondence_points_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">rand_points_1</span><span class="p">)</span>
        <span class="n">correspondence_points_2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">rand_points_2</span><span class="p">)</span>

        <span class="n">ref_H</span> <span class="o">=</span> <span class="n">computeH_norm</span><span class="p">(</span><span class="n">correspondence_points_1</span><span class="p">,</span> <span class="n">correspondence_points_2</span><span class="p">)</span>
        <span class="n">inliers</span><span class="p">,</span> <span class="n">inlier_count</span><span class="p">,</span> <span class="n">distance_error</span><span class="p">,</span> <span class="n">error_state</span> <span class="o">=</span> <span class="n">compute_inliers</span><span class="p">(</span><span class="n">ref_H</span><span class="p">,</span> 
                                                                            <span class="n">test_locs1</span><span class="p">,</span>
                                                                            <span class="n">test_locs2</span><span class="p">,</span> 
                                                                            <span class="n">inlier_tol</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">error_state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">inlier_count</span> <span class="o">&gt;</span> <span class="n">final_inlier_count</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">distance_error</span> <span class="o">&lt;</span> <span class="n">final_distance_error</span><span class="p">):</span>
            <span class="n">final_inlier_count</span> <span class="o">=</span> <span class="n">inlier_count</span>
            <span class="n">final_inliers</span> <span class="o">=</span> <span class="n">inliers</span>
            <span class="n">final_corresp_points_1</span> <span class="o">=</span> <span class="n">correspondence_points_1</span>
            <span class="n">final_corresp_points_2</span> <span class="o">=</span> <span class="n">correspondence_points_2</span>
            <span class="n">final_distance_error</span> <span class="o">=</span> <span class="n">distance_error</span>
            <span class="n">final_test_locs1</span> <span class="o">=</span> <span class="n">test_locs1</span>
            <span class="n">final_test_locs2</span> <span class="o">=</span> <span class="n">test_locs2</span>

    <span class="k">if</span> <span class="n">final_distance_error</span> <span class="o">!=</span> <span class="mi">10000</span><span class="p">:</span>
        <span class="c1"># print("original point count is", locs1.shape[0])
</span>        <span class="c1"># print("final inlier count is", final_inlier_count)
</span>        <span class="c1"># print("final inlier's cumulative distance error is", final_distance_error)
</span>
        <span class="n">delete_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">final_inliers</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">final_locs_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">final_test_locs1</span><span class="p">,</span> <span class="n">delete_indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">final_locs_2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">final_test_locs2</span><span class="p">,</span> <span class="n">delete_indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">final_locs_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">final_locs_1</span><span class="p">,</span> <span class="n">final_corresp_points_1</span><span class="p">))</span>
        <span class="n">final_locs_2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">final_locs_2</span><span class="p">,</span> <span class="n">final_corresp_points_2</span><span class="p">))</span>

        <span class="n">bestH2to1</span> <span class="o">=</span> <span class="n">computeH_norm</span><span class="p">(</span><span class="n">final_locs_1</span><span class="p">,</span> <span class="n">final_locs_2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bestH2to1</span><span class="p">,</span> <span class="n">final_inliers</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bestH2to1</span> <span class="o">=</span> <span class="n">computeH_norm</span><span class="p">(</span><span class="n">correspondence_points_1</span><span class="p">,</span> <span class="n">correspondence_points_2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bestH2to1</span><span class="p">,</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">compute_inliers</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
    <span class="s">"""
    Compute the number of inliers for a given
    homography matrix
    Args:
        h: Homography matrix
        x1 : matched points in image 1
        x2 : matched points in image 2
        tol: tolerance value to check for inliers

    Returns:
        inliers         : indexes of x1 or x2 which are inliers
        inlier_count    : number of total inliers
        dist_error_sum  : Cumulative sum of errors in reprojection error calc
        flag            : flag to indicate if H was invertible or not
    """</span>
    <span class="c1"># take H inv to map points in x1 to x2
</span>    <span class="k">try</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">inv</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>

    <span class="n">x2_extd</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x2</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x1_extd</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">x2_est</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x2_extd</span><span class="p">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x2_extd</span><span class="p">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">x2_est</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">H</span> <span class="o">@</span> <span class="n">x1_extd</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
    
    <span class="n">x2_est</span> <span class="o">=</span> <span class="n">x2_est</span><span class="o">/</span><span class="n">np</span><span class="p">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x2_est</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dist_error</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">((</span><span class="n">x2_extd</span><span class="o">-</span><span class="n">x2_est</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># print("dist error is", dist_error)
</span>    <span class="n">inliers</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">((</span><span class="n">dist_error</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">inlier_count</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">inliers</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">inliers</span><span class="p">,</span> <span class="n">inlier_count</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">dist_error</span><span class="p">),</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">compositeH</span><span class="p">(</span><span class="n">H2to1</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
    <span class="s">"""
    Create a composite image after warping the template image on top
    of the image using the homography

    Args:
        H2to1 : Existing(already found) homography matrix
        template: Harry Potter (template image)
        img: Base image onto which we overlay Harry Potter image

    Returns:
        composite_img: Base image with overlayed Harry Potter cover
    """</span>
    <span class="n">output_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># destination_img = img
</span>    <span class="c1"># source_img = template
</span>    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">inv</span><span class="p">(</span><span class="n">H2to1</span><span class="p">)</span>

    <span class="c1"># Create mask of same size as template
</span>    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="n">template</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">template</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">*</span><span class="mi">255</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">stack</span><span class="p">((</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Warp mask by appropriate homography
</span>    <span class="n">warped_mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">output_shape</span><span class="p">)</span>

    <span class="c1"># Warp template by appropriate homography
</span>    <span class="n">warped_template</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">output_shape</span><span class="p">)</span>

    <span class="c1"># Use mask to combine the warped template and the image
</span>    <span class="n">composite_img</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">warped_mask</span><span class="p">,</span> <span class="n">warped_template</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">composite_img</span>


<span class="k">def</span> <span class="nf">panorama_composite</span><span class="p">(</span><span class="n">H2to1</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
    <span class="s">"""
    Stitch two images together to form a panorama

    Args:
        H2to1: Homography Matrix
        template: The pano_right image
        img: The pano_left image

    Returns:
        composite_img: Stitched image (panorama)
    """</span>
    <span class="n">output_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">240</span><span class="p">,</span><span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">240</span><span class="p">)</span>
    <span class="c1"># destination_img = img
</span>    <span class="c1"># source_img = template
</span>    <span class="n">h</span> <span class="o">=</span> <span class="n">H2to1</span>
    
    <span class="n">img_padded</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">240</span><span class="p">,</span><span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">240</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">img</span><span class="p">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">img_padded</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span><span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,:,:]</span>

    <span class="c1"># Create mask of same size as template
</span>    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="n">template</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">template</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">*</span><span class="mi">255</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">stack</span><span class="p">((</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Warp mask by appropriate homography
</span>    <span class="n">warped_mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">output_shape</span><span class="p">)</span>

    <span class="c1"># Warp template by appropriate homography
</span>    <span class="n">cv2</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">"template image"</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
    <span class="n">cv2</span><span class="p">.</span><span class="n">waitKey</span><span class="p">()</span>
    <span class="n">cv2</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">"destination image"</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
    <span class="n">cv2</span><span class="p">.</span><span class="n">waitKey</span><span class="p">()</span>
    <span class="n">warped_template</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">output_shape</span><span class="p">)</span>

    <span class="n">cv2</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">"warped template"</span><span class="p">,</span> <span class="n">warped_template</span><span class="p">)</span>
    <span class="n">cv2</span><span class="p">.</span><span class="n">waitKey</span><span class="p">()</span>

    <span class="c1"># Use mask to combine the warped template and the image
</span>    <span class="n">composite_img</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">warped_mask</span><span class="p">,</span> <span class="n">warped_template</span><span class="p">,</span> <span class="n">img_padded</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">composite_img</span>
    
</code></pre></div></div><hr />
      <h1 id="applying-homography-estimation-in-the-real-world">
        
        
          <a href="#applying-homography-estimation-in-the-real-world" class="anchor-heading" aria-labelledby="applying-homography-estimation-in-the-real-world"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Applying Homography Estimation in the Real World
        
        
      </h1>
    
      <h2 id="basic-cool-applications">
        
        
          <a href="#basic-cool-applications" class="anchor-heading" aria-labelledby="basic-cool-applications"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Basic cool applications
        
        
      </h2>
    

<p>If we know how a template matches to a warped image, such as:</p>

<p><img src="/images/homography/15.png" alt="" /></p>

<p>We can then use this homography matrix to map any plane (here a different book cover) 
onto our destination image</p>

<p><img src="/images/homography/22.png" alt="" /></p>
      <h2 id="ar-video">
        
        
          <a href="#ar-video" class="anchor-heading" aria-labelledby="ar-video"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> AR Video
        
        
      </h2>
    

<p>Here we use the same book-cover homography mapping but onto a sequence of frames of a video</p>

<p><img src="/images/mp4ar_video_AdobeExpress.gif" alt="" /></p>
      <h2 id="panorama-stitching">
        
        
          <a href="#panorama-stitching" class="anchor-heading" aria-labelledby="panorama-stitching"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Panorama Stitching
        
        
      </h2>
    

<p>During my visit to Ohiopyle, I took few pictures of the river. 
Let’s back to the fact that homography works well for far
away scenes, where the large distance from camera to landscape makes the relative distances of 
objects in the landscape negligible. In such cases even small translations of the camera have a 
small effect on the landscape itself.</p>

<p>However, since the scene at ohiopyle was not too far away, any translation would yield a bad 
homography matrix and cause shoddy stitching. Therefore I tried to mitigate this by 
only rotating about my hip (to ensure no translational movement) while taking the two views.</p>

<p>The results of the stitching are shown below:</p>

<p><img src="/images/homography/23.png" alt="" /></p>
      <h1 id="acknowledgement-and-references">
        
        
          <a href="#acknowledgement-and-references" class="anchor-heading" aria-labelledby="acknowledgement-and-references"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Acknowledgement and References
        
        
      </h1>
    

<p>A lot of images are taken from the lecture slides during my computer vision class at CMU. These were
taught by Prof. Kris Kitani and Prof. Deva Ramanan</p>

<p>These slides are publicly available <a href="http://16720.courses.cs.cmu.edu/lec.html">(slides)</a></p>
      <h2 id="my-ohiopyle-trip">
        
        
          <a href="#my-ohiopyle-trip" class="anchor-heading" aria-labelledby="my-ohiopyle-trip"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> My Ohiopyle trip
        
        
      </h2>
    

<p><img src="/images/homography/25.jpeg" alt="" /></p>
      <h1 id="helper-functions">
        
        
          <a href="#helper-functions" class="anchor-heading" aria-labelledby="helper-functions"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Helper Functions
        
        
      </h1>
    
<p>The helper function in this framework is shown below:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="n">sio</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">skimage.feature</span>

<span class="n">PATCHWIDTH</span> <span class="o">=</span> <span class="mi">9</span>

<span class="k">def</span> <span class="nf">briefMatch</span><span class="p">(</span><span class="n">desc1</span><span class="p">,</span><span class="n">desc2</span><span class="p">,</span><span class="n">ratio</span><span class="p">):</span>

    <span class="n">matches</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">feature</span><span class="p">.</span><span class="n">match_descriptors</span><span class="p">(</span><span class="n">desc1</span><span class="p">,</span><span class="n">desc2</span><span class="p">,</span><span class="s">'hamming'</span><span class="p">,</span><span class="n">cross_check</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">max_ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">matches</span>



<span class="k">def</span> <span class="nf">plotMatches</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span><span class="n">im2</span><span class="p">,</span><span class="n">matches</span><span class="p">,</span><span class="n">locs1</span><span class="p">,</span><span class="n">locs2</span><span class="p">):</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">im1</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
    <span class="n">skimage</span><span class="p">.</span><span class="n">feature</span><span class="p">.</span><span class="n">plot_matches</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">im1</span><span class="p">,</span><span class="n">im2</span><span class="p">,</span><span class="n">locs1</span><span class="p">,</span><span class="n">locs2</span><span class="p">,</span><span class="n">matches</span><span class="p">,</span><span class="n">matches_color</span><span class="o">=</span><span class="s">'r'</span><span class="p">,</span><span class="n">only_matches</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span>



<span class="k">def</span> <span class="nf">makeTestPattern</span><span class="p">(</span><span class="n">patchWidth</span><span class="p">,</span> <span class="n">nbits</span><span class="p">):</span>

    <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">compareX</span> <span class="o">=</span> <span class="n">patchWidth</span><span class="o">*</span><span class="n">patchWidth</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">((</span><span class="n">nbits</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">compareX</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="n">compareX</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">compareY</span> <span class="o">=</span> <span class="n">patchWidth</span><span class="o">*</span><span class="n">patchWidth</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">((</span><span class="n">nbits</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">compareY</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="n">compareY</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">compareX</span><span class="p">,</span> <span class="n">compareY</span><span class="p">)</span>




<span class="k">def</span> <span class="nf">computePixel</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">center</span><span class="p">):</span>

    <span class="n">halfWidth</span> <span class="o">=</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">col1</span> <span class="o">=</span> <span class="n">idx1</span> <span class="o">%</span> <span class="n">width</span> <span class="o">-</span> <span class="n">halfWidth</span>
    <span class="n">row1</span> <span class="o">=</span> <span class="n">idx1</span> <span class="o">//</span> <span class="n">width</span> <span class="o">-</span> <span class="n">halfWidth</span>
    <span class="n">col2</span> <span class="o">=</span> <span class="n">idx2</span> <span class="o">%</span> <span class="n">width</span> <span class="o">-</span> <span class="n">halfWidth</span>
    <span class="n">row2</span> <span class="o">=</span> <span class="n">idx2</span> <span class="o">//</span> <span class="n">width</span> <span class="o">-</span> <span class="n">halfWidth</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">img</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">row1</span><span class="p">)][</span><span class="nb">int</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">col1</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">row2</span><span class="p">)][</span><span class="nb">int</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">col2</span><span class="p">)]</span> <span class="k">else</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">computeBrief</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">locs</span><span class="p">):</span>

    <span class="n">patchWidth</span> <span class="o">=</span> <span class="mi">9</span>
    <span class="n">nbits</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">compareX</span><span class="p">,</span> <span class="n">compareY</span> <span class="o">=</span> <span class="n">makeTestPattern</span><span class="p">(</span><span class="n">patchWidth</span><span class="p">,</span><span class="n">nbits</span><span class="p">)</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">img</span><span class="p">.</span><span class="n">shape</span>

    <span class="n">halfWidth</span> <span class="o">=</span> <span class="n">patchWidth</span><span class="o">//</span><span class="mi">2</span>

    <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">halfWidth</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-</span><span class="n">halfWidth</span> <span class="ow">and</span> <span class="n">halfWidth</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="n">halfWidth</span><span class="p">,</span> <span class="n">locs</span><span class="p">)))</span>
    <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">computePixel</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">patchWidth</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="nb">zip</span><span class="p">(</span><span class="n">compareX</span><span class="p">,</span> <span class="n">compareY</span><span class="p">)))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">locs</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">desc</span><span class="p">,</span> <span class="n">locs</span>



<span class="k">def</span> <span class="nf">corner_detection</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>

    <span class="c1"># fast method
</span>    <span class="n">result_img</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">feature</span><span class="p">.</span><span class="n">corner_fast</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">PATCHWIDTH</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">locs</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">feature</span><span class="p">.</span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">result_img</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">locs</span>


<span class="k">def</span> <span class="nf">loadVid</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>

    <span class="c1"># Create a VideoCapture object and read from input file
</span>    <span class="c1"># If the input is the camera, pass 0 instead of the video file name
</span>
    <span class="n">cap</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">VideoCapture</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="c1"># Append frames to list
</span>    <span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Check if camera opened successfully
</span>    <span class="k">if</span> <span class="n">cap</span><span class="p">.</span><span class="n">isOpened</span><span class="p">()</span><span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Error opening video stream or file"</span><span class="p">)</span>

    <span class="c1"># Read until video is completed
</span>    <span class="k">while</span><span class="p">(</span><span class="n">cap</span><span class="p">.</span><span class="n">isOpened</span><span class="p">()):</span>

        <span class="c1"># Capture frame-by-frame
</span>        <span class="n">ret</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
            <span class="c1">#Store the resulting frame
</span>            <span class="n">frames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># When everything done, release the video capture object
</span>    <span class="n">cap</span><span class="p">.</span><span class="n">release</span><span class="p">()</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">stack</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">frames</span>
</code></pre></div></div>

        

        

        
        
          <hr>
          <footer>
            

            <p class="text-small text-grey-dk-100 mb-0"></p>

            
              <div class="d-flex mt-2">
                
                
              </div>
            
          </footer>
        

      </div>
    </div>

    
      

      <div class="search-overlay"></div>
    
  </div>
</body>
</html>

